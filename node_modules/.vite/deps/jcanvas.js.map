{
  "version": 3,
  "sources": ["../../jcanvas/src/jcanvas.ts"],
  "sourcesContent": ["/**\n * @license jCanvas\n * Copyright 2017-2024 Caleb Evans\n * Released under the MIT license\n */\nimport $ from \"jquery\";\nimport \"./jcanvas.d\";\n\n// Define local aliases t o frequently used properties\nconst extendObject = Object.assign,\n\tinArray = $.inArray,\n\ttypeOf = function (operand: any) {\n\t\treturn Object.prototype.toString.call(operand).slice(8, -1).toLowerCase();\n\t},\n\tisPlainObject = $.isPlainObject,\n\t// Math constants and functions\n\tPI = Math.PI,\n\tround = Math.round,\n\tabs = Math.abs,\n\tsin = Math.sin,\n\tcos = Math.cos,\n\tatan2 = Math.atan2,\n\t// jQuery's internal event normalization function\n\tjQueryEventFix = ($.event as JQueryEventWithFix).fix,\n\t// Object for storing a number of internal property maps\n\tmaps: JCanvasMaps = {\n\t\t// Map drawing names with their respective method names\n\t\tdrawings: {\n\t\t\tarc: \"drawArc\",\n\t\t\tbezier: \"drawBezier\",\n\t\t\tellipse: \"drawEllipse\",\n\t\t\tfunction: \"draw\",\n\t\t\timage: \"drawImage\",\n\t\t\tline: \"drawLine\",\n\t\t\tpath: \"drawPath\",\n\t\t\tpolygon: \"drawPolygon\",\n\t\t\tslice: \"drawSlice\",\n\t\t\tquadratic: \"drawQuadratic\",\n\t\t\trectangle: \"drawRect\",\n\t\t\ttext: \"drawText\",\n\t\t\tvector: \"drawVector\",\n\t\t\tsave: \"saveCanvas\",\n\t\t\trestore: \"restoreCanvas\",\n\t\t\trotate: \"rotateCanvas\",\n\t\t\tscale: \"scaleCanvas\",\n\t\t\ttranslate: \"translateCanvas\",\n\t\t},\n\t\ttouchEvents: {\n\t\t\tmousedown: \"touchstart\",\n\t\t\tmouseup: \"touchend\",\n\t\t\tmousemove: \"touchmove\",\n\t\t},\n\t\t// Map standard touch events to mouse events\n\t\tmouseEvents: {\n\t\t\ttouchstart: \"mousedown\",\n\t\t\ttouchend: \"mouseup\",\n\t\t\ttouchmove: \"mousemove\",\n\t\t},\n\t},\n\t// jQuery internal caches\n\tcaches: JCanvasCache = {\n\t\tdataCache: {},\n\t\tpropCache: {},\n\t\timageCache: {},\n\t\tpathCache: {},\n\t},\n\t// Base transformations\n\tbaseTransforms: JCanvasBaseTransforms = {\n\t\trotate: 0,\n\t\tscaleX: 1,\n\t\tscaleY: 1,\n\t\ttranslateX: 0,\n\t\ttranslateY: 0,\n\t\t// Store all previous masks\n\t\tmasks: [],\n\t},\n\tcss: JCanvasCss = {\n\t\t// Define properties used in both CSS and jCanvas\n\t\tprops: [\"width\", \"height\", \"opacity\", \"lineHeight\"],\n\t\tpropsObj: {},\n\t},\n\ttangibleEvents: (\n\t\t| JCanvasMouseEventName\n\t\t| JCanvasTouchEventName\n\t\t| JCanvasPointerEventName\n\t)[] = [\n\t\t\"mousedown\",\n\t\t\"mousemove\",\n\t\t\"mouseup\",\n\t\t\"mouseover\",\n\t\t\"mouseout\",\n\t\t\"touchstart\",\n\t\t\"touchmove\",\n\t\t\"touchend\",\n\t\t\"pointerdown\",\n\t\t\"pointermove\",\n\t\t\"pointerup\",\n\t];\n\n// jCanvas object in which global settings are other data are stored\nconst jCanvas = {\n\t// Events object for storing jCanvas event initiation functions\n\tevents: {},\n\t// Object containing all jCanvas event hooks\n\teventHooks: {},\n\t// Settings for enabling future jCanvas features\n\tfuture: {},\n\t// Need to type assert since some public API methods like transformShape are\n\t// lazily added to this object\n} as JCanvas;\n\n// jCanvas default property values\nclass jCanvasDefaults implements JCanvasDefaults {\n\talign: CanvasRenderingContext2D[\"textAlign\"] = \"center\";\n\tarrowAngle: number = 90;\n\tarrowRadius: number = 0;\n\tautosave: boolean = true;\n\tbaseline: CanvasRenderingContext2D[\"textBaseline\"] = \"middle\";\n\tbringToFront: boolean = false;\n\tcanvas: HTMLCanvasElement | null = null;\n\tccw: boolean = false;\n\tclosed: boolean = false;\n\tcompositing: CanvasRenderingContext2D[\"globalCompositeOperation\"] =\n\t\t\"source-over\";\n\tconcavity: number = 0;\n\tcornerRadius: number = 0;\n\tcount: number = 1;\n\tcropFromCenter: boolean = true;\n\tcrossOrigin: HTMLImageElement[\"crossOrigin\"] = null;\n\tcursors: Record<string, string> | null = null;\n\tdisableEvents: boolean = false;\n\tdraggable: boolean = false;\n\tdragging: boolean = false;\n\tdragGroups: string[] | null = null;\n\tgroups: string[] | null = null;\n\td: string | null = null;\n\tdata: object | null = null;\n\tdx: number = 0;\n\tdy: number = 0;\n\tend: number = 360;\n\tendArrow: boolean = false;\n\teventX: number | null = null;\n\teventY: number | null = null;\n\tfillRule: CanvasFillRule = \"nonzero\";\n\tfillStyle: string | CanvasGradient | CanvasPattern | JCanvasStyleFunction =\n\t\t\"transparent\";\n\tflipArcText: boolean = false;\n\tfontStyle: string = \"normal\";\n\tfontSize: string = \"12pt\";\n\tfontFamily: string = \"sans-serif\";\n\tfromCenter: boolean = true;\n\theight: number | null = null;\n\timageSmoothing: boolean = true;\n\tinDegrees: boolean = true;\n\tintangible: boolean = false;\n\tindex: number | null = null;\n\tintersects: boolean = false;\n\tletterSpacing: number | null = null;\n\tlineHeight: number = 1;\n\tlayer: boolean = false;\n\tmask: boolean = false;\n\tmaxWidth: number | null = null;\n\tmethod: keyof JQuery | null = null;\n\tmiterLimit: number = 10;\n\tname: string | null = null;\n\topacity: number = 1;\n\tr1: number | null = null;\n\tr2: number | null = null;\n\tradius: number = 0;\n\trepeat: Parameters<CanvasRenderingContext2D[\"createPattern\"]>[1] = \"repeat\";\n\trespectAlign: boolean = false;\n\trestrictDragToAxis: \"x\" | \"y\" | null = null;\n\trotate: number = 0;\n\trounded: boolean = false;\n\tscale: number = 1;\n\tscaleX: number = 1;\n\tscaleY: number = 1;\n\tshadowBlur: number = 0;\n\tshadowColor: string = \"transparent\";\n\tshadowStroke: boolean = false;\n\tshadowX: number = 0;\n\tshadowY: number = 0;\n\tsHeight: number | null = null;\n\tsides: number = 0;\n\tsource: string | HTMLImageElement | HTMLCanvasElement = \"\";\n\tspread: number = 0;\n\tstart: number = 0;\n\tstartArrow: boolean = false;\n\tstrokeCap: CanvasRenderingContext2D[\"lineCap\"] = \"butt\";\n\tstrokeDash: number[] | null = null;\n\tstrokeDashOffset: CanvasRenderingContext2D[\"lineDashOffset\"] = 0;\n\tstrokeJoin: CanvasRenderingContext2D[\"lineJoin\"] = \"miter\";\n\tstrokeStyle: string | CanvasGradient | CanvasPattern | JCanvasStyleFunction =\n\t\t\"transparent\";\n\tstrokeWidth: number = 1;\n\tstyle: Record<string, boolean> = {};\n\tsWidth: number | null = null;\n\tsx: number | null = null;\n\tsy: number | null = null;\n\ttext: string = \"\";\n\ttranslate: number = 0;\n\ttranslateX: number = 0;\n\ttranslateY: number = 0;\n\ttype: string | null = null;\n\tvisible: boolean = true;\n\twidth: number | null = null;\n\twillReadFrequently: boolean = false;\n\tx: number = 0;\n\ty: number = 0;\n\t[key: `x${number}`]: number;\n\t[key: `y${number}`]: number;\n\t[key: `cx${number}`]: number;\n\t[key: `cy${number}`]: number;\n\t[key: `a${number}`]: number;\n\t[key: `l${number}`]: number;\n\t[key: `p${number}`]: number;\n\t[key: `_${string}`]: any;\n}\nconst defaults = new jCanvasDefaults();\n\n// Constructor for creating objects that inherit from jCanvas preferences and defaults\nconst jCanvasObject: JCanvasObjectFunction = function jCanvasObject(args) {\n\treturn extendObject(this, args);\n} as JCanvasObjectFunction;\njCanvasObject.prototype = defaults;\n\n// Constructor for creating a fully-qualified jCanvas layer\nconst jCanvasLayer: JCanvasLayerFunction = function jCanvasLayer(\n\tcanvas,\n\tparams\n) {\n\tObject.assign(this, params, {\n\t\tcanvas,\n\t\t_layer: true,\n\t});\n} as JCanvasLayerFunction;\njCanvasLayer.prototype = jCanvasObject.prototype;\n\nfunction _getParamsObject(args?: Partial<JCanvasObject>) {\n\treturn args?._layer ? (args as JCanvasLayer) : new jCanvasObject(args);\n}\n\n/* Internal helper methods */\n\n// Determines if the given operand is a string\nfunction isString(operand: any): operand is string {\n\treturn typeOf(operand) === \"string\";\n}\n\n// Determines if the given operand is a function\nfunction isFunction(operand: any): operand is Function {\n\treturn typeOf(operand) === \"function\";\n}\n\n// Determines if the given operand is numeric\nfunction isNumeric(operand: any): operand is number | string {\n\treturn !isNaN(Number(operand)) && !isNaN(parseFloat(operand));\n}\n\n// Tells TypeScript that the given element is a canvas\nfunction _isCanvas(element: HTMLElement): element is HTMLCanvasElement {\n\treturn element instanceof HTMLCanvasElement;\n}\n\n// Get 2D context for the given canvas\nfunction _getContext(\n\tcanvas: HTMLCanvasElement\n): CanvasRenderingContext2D | null {\n\tif ($.jCanvas.defaults.willReadFrequently) {\n\t\treturn canvas.getContext(\"2d\", {\n\t\t\twillReadFrequently: $.jCanvas.defaults.willReadFrequently,\n\t\t});\n\t} else {\n\t\treturn canvas.getContext(\"2d\");\n\t}\n}\n\n// Coerce designated number properties from strings to numbers\nfunction _coerceNumericProps(props: Partial<JCanvasObject>) {\n\t// Loop through all properties in given property map\n\tfor (const propName in props) {\n\t\tif (Object.prototype.hasOwnProperty.call(props, propName)) {\n\t\t\tconst propValue = props[propName as keyof typeof props];\n\t\t\tconst propType = typeOf(propValue);\n\t\t\t// If property is non-empty string and value is numeric\n\t\t\tif (\n\t\t\t\tpropType === \"string\" &&\n\t\t\t\tisNumeric(propValue) &&\n\t\t\t\tpropName !== \"text\"\n\t\t\t) {\n\t\t\t\t// Convert value to number\n\t\t\t\tprops[propName as keyof typeof props] = parseFloat(String(propValue));\n\t\t\t}\n\t\t}\n\t}\n\t// Ensure value of text property is always a string\n\tif (props.text !== undefined) {\n\t\tprops.text = String(props.text);\n\t}\n}\n\n// Clone the given transformations object\nfunction _cloneTransforms(transforms: JCanvasBaseTransforms) {\n\t// Clone the object itself\n\ttransforms = extendObject({}, transforms);\n\t// Clone the object's masks array\n\ttransforms.masks = transforms.masks.slice(0);\n\treturn transforms;\n}\n\n// Save canvas context and update transformation stack\nfunction _saveCanvas(ctx: CanvasRenderingContext2D, data: JCanvasInternalData) {\n\tctx.save();\n\tconst transforms = _cloneTransforms(data.transforms);\n\tdata.savedTransforms.push(transforms);\n}\n\n// Restore canvas context update transformation stack\nfunction _restoreCanvas(\n\tctx: CanvasRenderingContext2D,\n\tdata: JCanvasInternalData\n) {\n\tif (data.savedTransforms.length === 0) {\n\t\t// Reset transformation state if it can't be restored any more\n\t\tdata.transforms = _cloneTransforms(baseTransforms);\n\t} else {\n\t\t// Restore canvas context\n\t\tctx.restore();\n\t\t// Restore current transform state to the last saved state\n\t\tconst lastTransform = data.savedTransforms.pop();\n\t\tif (lastTransform) {\n\t\t\tdata.transforms = lastTransform;\n\t\t}\n\t}\n}\n\n// Set the style with the given name\nfunction _setStyle(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tstyleName: \"fillStyle\" | \"strokeStyle\"\n) {\n\tconst styleValue = params[styleName];\n\tif (styleValue) {\n\t\tif (isFunction(styleValue)) {\n\t\t\t// Handle functions\n\t\t\tctx[styleName] = styleValue.call(canvas, params);\n\t\t} else {\n\t\t\t// Handle string, gradients, and patterns\n\t\t\tctx[styleName] = styleValue;\n\t\t}\n\t}\n}\n\n// Set canvas context properties\nfunction _setGlobalProps(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject\n) {\n\t_setStyle(canvas, ctx, params, \"fillStyle\");\n\t_setStyle(canvas, ctx, params, \"strokeStyle\");\n\tctx.lineWidth = params.strokeWidth;\n\t// Optionally round corners for paths\n\tif (params.rounded) {\n\t\tctx.lineCap = ctx.lineJoin = \"round\";\n\t} else {\n\t\tctx.lineCap = params.strokeCap;\n\t\tctx.lineJoin = params.strokeJoin;\n\t\tctx.miterLimit = params.miterLimit;\n\t}\n\t// Reset strokeDash if null\n\tif (!params.strokeDash) {\n\t\tparams.strokeDash = [];\n\t}\n\t// Dashed lines\n\tif (ctx.setLineDash) {\n\t\tctx.setLineDash(params.strokeDash);\n\t}\n\t// @ts-expect-error Permit vendor-prefixed property\n\tctx.webkitLineDash = params.strokeDash;\n\tctx.lineDashOffset =\n\t\t// @ts-expect-error Permit vendor-prefixed property\n\t\tctx.webkitLineDashOffset =\n\t\t// @ts-expect-error Permit vendor-prefixed property\n\t\tctx.mozDashOffset =\n\t\t\tparams.strokeDashOffset;\n\t// Drop shadow\n\tctx.shadowOffsetX = params.shadowX;\n\tctx.shadowOffsetY = params.shadowY;\n\tctx.shadowBlur = params.shadowBlur;\n\tctx.shadowColor = params.shadowColor;\n\t// Opacity and composite operation\n\tctx.globalAlpha = params.opacity;\n\tctx.globalCompositeOperation = params.compositing;\n\t// Support cross-browser toggling of image smoothing\n\tif (params.imageSmoothing) {\n\t\tctx.imageSmoothingEnabled = params.imageSmoothing;\n\t}\n}\n\n// Optionally enable masking support for this path\nfunction _enableMasking(\n\tctx: CanvasRenderingContext2D,\n\tdata: JCanvasInternalData,\n\tparams: JCanvasObject\n) {\n\tif (params.mask) {\n\t\t// If jCanvas autosave is enabled\n\t\tif (params.autosave) {\n\t\t\t// Automatically save transformation state by default\n\t\t\t_saveCanvas(ctx, data);\n\t\t}\n\t\t// Clip the current path\n\t\tif (params._path) {\n\t\t\tctx.clip(params._path, params.fillRule);\n\t\t} else {\n\t\t\tctx.clip(params.fillRule);\n\t\t}\n\t\t// Keep track of current masks\n\t\tdata.transforms.masks.push(params._args);\n\t}\n}\n\n// Restore individual shape transformation\nfunction _restoreTransform(\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject\n) {\n\t// If shape has been transformed by jCanvas\n\tif (params._transformed) {\n\t\t// Restore canvas context\n\t\tctx.restore();\n\t}\n}\n\n// Close current canvas path\nfunction _closePath(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject\n) {\n\t// Optionally close path\n\tif (params.closed) {\n\t\tctx.closePath();\n\t}\n\n\tif (params.shadowStroke && params.strokeWidth !== 0) {\n\t\t// Extend the shadow to include the stroke of a drawing\n\n\t\t// Add a stroke shadow by stroking before filling\n\t\tif (params._path) {\n\t\t\tctx.stroke(params._path);\n\t\t\tctx.fill(params._path, params.fillRule);\n\t\t} else {\n\t\t\tctx.stroke();\n\t\t\tctx.fill(params.fillRule);\n\t\t}\n\t\t// Ensure the below stroking does not inherit a shadow\n\t\tctx.shadowColor = \"transparent\";\n\t\tctx.shadowBlur = 0;\n\t\t// Stroke over fill as usual\n\t\tif (params._path) {\n\t\t\tctx.stroke(params._path);\n\t\t} else {\n\t\t\tctx.stroke();\n\t\t}\n\t} else {\n\t\t// If shadowStroke is not enabled, stroke & fill as usual\n\n\t\tif (params._path) {\n\t\t\tctx.fill(params._path, params.fillRule);\n\t\t} else {\n\t\t\tctx.fill(params.fillRule);\n\t\t}\n\t\t// Prevent extra shadow created by stroke (but only when fill is present)\n\t\tif (params.fillStyle !== \"transparent\") {\n\t\t\tctx.shadowColor = \"transparent\";\n\t\t}\n\t\tif (params.strokeWidth !== 0) {\n\t\t\t// Only stroke if the stroke is not 0\n\t\t\tif (params._path) {\n\t\t\t\tctx.stroke(params._path);\n\t\t\t} else {\n\t\t\t\tctx.stroke();\n\t\t\t}\n\t\t}\n\t}\n\n\t// Optionally close path\n\tif (!params.closed) {\n\t\tctx.closePath();\n\t}\n\n\t// Restore individual shape transformation\n\t_restoreTransform(ctx, params);\n\n\t// Mask shape if chosen\n\tif (params.mask) {\n\t\t// Retrieve canvas data\n\t\tconst data = _getCanvasData(canvas);\n\t\t_enableMasking(ctx, data, params);\n\t}\n}\n\n// Transform (translate, scale, or rotate) shape\nfunction _transformShape(\n\t_canvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\twidth: number | null = null,\n\theight: number | null = null\n) {\n\t// Get conversion factor for radians\n\tparams._toRad = params.inDegrees ? PI / 180 : 1;\n\n\tparams._transformed = true;\n\tctx.save();\n\n\t// Optionally measure (x, y) position from top-left corner\n\tif (\n\t\t!params.fromCenter &&\n\t\t!params._centered &&\n\t\twidth !== null &&\n\t\theight !== null\n\t) {\n\t\t// Always draw from center unless otherwise specified\n\t\tif (height === undefined) {\n\t\t\theight = width;\n\t\t}\n\t\tparams.x += width / 2;\n\t\tparams.y += height / 2;\n\t\tparams._centered = true;\n\t}\n\t// Optionally rotate shape\n\tif (params.rotate) {\n\t\t_rotateCanvas(ctx, params, null);\n\t}\n\t// Optionally scale shape\n\tif (params.scale !== 1 || params.scaleX !== 1 || params.scaleY !== 1) {\n\t\t_scaleCanvas(ctx, params, null);\n\t}\n\t// Optionally translate shape\n\tif (params.translate || params.translateX || params.translateY) {\n\t\t_translateCanvas(ctx, params, null);\n\t}\n}\n\n/* Plugin API */\n\n// Extend jCanvas with a user-defined method\njCanvas.extend = function extend(plugin) {\n\t// Create plugin\n\tif (plugin.name) {\n\t\t// Merge properties with defaults\n\t\tif (plugin.props) {\n\t\t\textendObject(defaults, plugin.props);\n\t\t}\n\t\t// Define plugin method\n\t\t// @ts-expect-error TODO: fix this\n\t\t$.fn[plugin.name] = function self(args) {\n\t\t\tconst $canvases = this;\n\n\t\t\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\t\t\tconst canvas = $canvases[e];\n\t\t\t\tif (!_isCanvas(canvas)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst ctx = _getContext(canvas);\n\t\t\t\tif (!ctx) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst params = _getParamsObject(args);\n\t\t\t\t_addLayer(canvas, params, args, self);\n\n\t\t\t\t_setGlobalProps(canvas, ctx, params);\n\t\t\t\tplugin.fn.call(canvas, ctx, params);\n\t\t\t}\n\t\t\treturn $canvases;\n\t\t};\n\t\t// Add drawing type to drawing map\n\t\tif (plugin.type) {\n\t\t\tmaps.drawings[plugin.type] = plugin.name as string;\n\t\t}\n\t}\n\t// @ts-expect-error TODO: fix this\n\treturn $.fn[plugin.name];\n};\n\n/* Layer API */\n\nclass JCanvasInternalData {\n\t// The associated canvas element\n\tcanvas: HTMLCanvasElement;\n\t// Layers array\n\tlayers: JCanvasLayer[] = [];\n\t// Layer maps\n\tlayer: {\n\t\tnames: Record<string, JCanvasLayer>;\n\t\tgroups: Record<string, JCanvasLayer[]>;\n\t} = {\n\t\tnames: {},\n\t\tgroups: {},\n\t};\n\teventHooks = {};\n\t// All layers that intersect with the event coordinates (regardless of visibility)\n\tintersecting: JCanvasLayer[] = [];\n\t// The topmost layer whose area contains the event coordinates\n\tlastIntersected: JCanvasLayer | null = null;\n\tcursor: string;\n\t// Properties for the current drag event\n\tdrag = {\n\t\tlayer: null as JCanvasLayer | null,\n\t\tdragging: false,\n\t};\n\t// Data for the current event\n\tevent: {\n\t\ttype: JCanvasInteractionEventName | null;\n\t\tx: number | null;\n\t\ty: number | null;\n\t\tevent?: Event | null;\n\t} = {\n\t\ttype: null,\n\t\tx: null,\n\t\ty: null,\n\t};\n\t// Events which already have been bound to the canvas\n\tevents: Record<string, boolean> = {};\n\t// The canvas's current transformation state\n\ttransforms: JCanvasBaseTransforms;\n\tsavedTransforms: JCanvasBaseTransforms[] = [];\n\t// Whether a layer is being animated or not\n\tanimating = false;\n\t// The layer currently being animated\n\tanimated: JCanvasLayer | null = null;\n\t// The device pixel ratio\n\tpixelRatio = 1;\n\t// Whether pixel ratio transformations have been applied\n\tscaled = false;\n\t// Whether the canvas should be redrawn when a layer mousemove\n\t// event triggers (either directly, or indirectly via dragging)\n\tredrawOnMousemove = false;\n\toriginalRedrawOnMousemove = false;\n\tdrawLayersComplete?: () => void;\n\tconstructor(canvas: HTMLCanvasElement) {\n\t\tthis.canvas = canvas;\n\t\tthis.cursor = $(canvas).css(\"cursor\");\n\t\tthis.transforms = _cloneTransforms(baseTransforms);\n\t}\n}\n\n// Retrieved the stored jCanvas data for a canvas element\nfunction _getCanvasData(canvas: HTMLCanvasElement) {\n\tconst dataCache = caches.dataCache;\n\tlet data: JCanvasInternalData;\n\tif (dataCache._canvas === canvas && dataCache._data) {\n\t\t// Retrieve canvas data from cache if possible\n\t\tdata = dataCache._data;\n\t} else {\n\t\t// Retrieve canvas data from jQuery's internal data storage\n\t\tdata = $.data(canvas, \"jCanvas\");\n\t\tif (!data) {\n\t\t\t// Create canvas data object if it does not already exist\n\t\t\tdata = new JCanvasInternalData(canvas);\n\t\t\t// Use jQuery to store canvas data\n\t\t\t$.data(canvas, \"jCanvas\", data);\n\t\t}\n\t\t// Cache canvas data for faster retrieval\n\t\tdataCache._canvas = canvas;\n\t\tdataCache._data = data;\n\t}\n\treturn data;\n}\n\n// Initialize all of a layer's associated jCanvas events\nfunction _addLayerEvents(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer\n) {\n\t// Determine which jCanvas events need to be bound to this layer\n\tfor (const eventName in jCanvas.events) {\n\t\tif (Object.prototype.hasOwnProperty.call(jCanvas.events, eventName)) {\n\t\t\t// If layer has callback function to complement it\n\t\t\tif (\n\t\t\t\tlayer[eventName as keyof JCanvasLayer] ||\n\t\t\t\tlayer.cursors?.[eventName]\n\t\t\t) {\n\t\t\t\t// Bind event to layer\n\t\t\t\t_addExplicitLayerEvent($canvas, data, layer, eventName);\n\t\t\t}\n\t\t}\n\t}\n\tif (!data.events.mouseout) {\n\t\t$canvas.on(\"mouseout.jCanvas\", function () {\n\t\t\tlet shouldRedraw = false;\n\t\t\t// Retrieve the layer whose drag event was canceled\n\t\t\tconst dragLayer = data.drag.layer;\n\t\t\t// If cursor mouses out of canvas while dragging\n\t\t\tif (dragLayer) {\n\t\t\t\t// Cancel drag\n\t\t\t\tdata.drag = { layer: null, dragging: false };\n\t\t\t\t_triggerLayerEvent($canvas, data, dragLayer, \"dragcancel\");\n\t\t\t\tshouldRedraw = true;\n\t\t\t}\n\t\t\t// Loop through all layers\n\t\t\tfor (let l = 0; l < data.layers.length; l += 1) {\n\t\t\t\tlayer = data.layers[l];\n\t\t\t\t// If layer thinks it's still being moused over\n\t\t\t\tif (layer?._hovered) {\n\t\t\t\t\t// Trigger mouseout on layer\n\t\t\t\t\t$canvas.triggerLayerEvent(data.layers[l], \"mouseout\");\n\t\t\t\t\tshouldRedraw = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Redraw layers only if an event has been triggered\n\t\t\tif (shouldRedraw) {\n\t\t\t\t$canvas.drawLayers();\n\t\t\t}\n\t\t});\n\t\t// Indicate that an event handler has been bound\n\t\tdata.events.mouseout = true;\n\t}\n}\n\n// Initialize the given event on the given layer\nfunction _addLayerEvent(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer,\n\teventName: string\n) {\n\t// Use touch events if appropriate\n\t// eventName = _getMouseEventName(eventName);\n\t// Bind event to layer\n\tjCanvas.events[eventName]($canvas, data);\n\tlayer._event = true;\n}\n\n// Add a layer event that was explicitly declared in the layer's parameter map,\n// excluding events added implicitly (e.g. mousemove event required by draggable\n// layers)\nfunction _addExplicitLayerEvent(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer,\n\teventName: string\n) {\n\t_addLayerEvent($canvas, data, layer, eventName);\n\tif (\n\t\teventName === \"mouseover\" ||\n\t\teventName === \"mouseout\" ||\n\t\teventName === \"mousemove\"\n\t) {\n\t\tdata.redrawOnMousemove = true;\n\t}\n}\n\n// Enable drag support for this layer\nfunction _enableDrag(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer\n) {\n\t// Only make layer draggable if necessary\n\tif (layer.draggable || layer.cursors) {\n\t\t// Organize helper events which enable drag support\n\t\tconst dragHelperEvents = [\"mousedown\", \"mousemove\", \"mouseup\"];\n\n\t\t// Bind each helper event to the canvas\n\t\tfor (let i = 0; i < dragHelperEvents.length; i += 1) {\n\t\t\t// Use touch events if appropriate\n\t\t\tconst eventName = dragHelperEvents[i];\n\t\t\t// Bind event\n\t\t\t_addLayerEvent($canvas, data, layer, eventName);\n\t\t}\n\t\t// Indicate that this layer has events bound to it\n\t\tlayer._event = true;\n\t}\n}\n\n// Update a layer property map if property is changed\nfunction _updateLayerName(\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer,\n\tprops?: Partial<JCanvasObject>\n) {\n\tconst nameMap = data.layer.names;\n\n\t// If layer name is being added, not changed\n\tif (!props) {\n\t\tprops = layer;\n\t} else {\n\t\t// Remove old layer name entry because layer name has changed\n\t\tif (\n\t\t\tprops.name !== undefined &&\n\t\t\tisString(layer.name) &&\n\t\t\tlayer.name !== props.name\n\t\t) {\n\t\t\tdelete nameMap[layer.name];\n\t\t}\n\t}\n\n\t// Add new entry to layer name map with new name\n\tif (isString(props.name)) {\n\t\tnameMap[props.name] = layer;\n\t}\n}\n\n// Create or update the data map for the given layer and group type\nfunction _updateLayerGroups(\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer,\n\tprops?: Partial<JCanvasObject>\n) {\n\tconst groupMap = data.layer.groups;\n\tlet index: number | undefined = undefined;\n\n\t// If group name is not changing\n\tif (!props) {\n\t\tprops = layer;\n\t} else {\n\t\t// Remove layer from all of its associated groups\n\t\tif (props.groups !== undefined && layer.groups !== null) {\n\t\t\tfor (let g = 0; g < layer.groups.length; g += 1) {\n\t\t\t\tconst groupName = layer.groups[g];\n\t\t\t\tconst group = groupMap[groupName];\n\t\t\t\tif (group) {\n\t\t\t\t\t// Remove layer from its old layer group entry\n\t\t\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t\t\tif (group[l] === layer) {\n\t\t\t\t\t\t\t// Keep track of the layer's initial index\n\t\t\t\t\t\t\tindex = l;\n\t\t\t\t\t\t\t// Remove layer once found\n\t\t\t\t\t\t\tgroup.splice(l, 1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Remove layer group entry if group is empty\n\t\t\t\t\tif (group.length === 0) {\n\t\t\t\t\t\tdelete groupMap[groupName];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add layer to new group if a new group name is given\n\tif (props.groups !== undefined && props.groups !== null) {\n\t\tfor (let g = 0; g < props.groups.length; g += 1) {\n\t\t\tconst groupName = props.groups[g];\n\n\t\t\tlet group = groupMap[groupName];\n\t\t\tif (!group) {\n\t\t\t\t// Create new group entry if it doesn't exist\n\t\t\t\tgroup = groupMap[groupName] = [];\n\t\t\t}\n\t\t\tif (index === undefined) {\n\t\t\t\t// Add layer to end of group unless otherwise stated\n\t\t\t\tindex = group.length;\n\t\t\t}\n\t\t\t// Add layer to its new layer group\n\t\t\tgroup.splice(index, 0, layer);\n\t\t}\n\t}\n}\n\n// Get event hooks object for the first selected canvas\n$.fn.getEventHooks = function getEventHooks() {\n\tconst $canvases = this;\n\n\tif ($canvases.length !== 0) {\n\t\tconst canvas = $canvases[0];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\treturn {};\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\t\treturn data.eventHooks;\n\t}\n\treturn {};\n};\n\n// Set event hooks for the selected canvases\n$.fn.setEventHooks = function setEventHooks(eventHooks) {\n\tconst $canvases = this;\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\t\textendObject(data.eventHooks, eventHooks);\n\t}\n\treturn $canvases;\n};\n\n// Get jCanvas layers array\n$.fn.getLayers = function getLayers(callback) {\n\tconst $canvases = this;\n\tlet matching: JCanvasLayer[] = [];\n\n\tif ($canvases.length !== 0) {\n\t\tconst canvas = $canvases[0];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\treturn matching;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\t\t// Retrieve layers array for this canvas\n\t\tconst layers = data.layers;\n\n\t\t// If a callback function is given\n\t\tif (isFunction(callback)) {\n\t\t\t// Filter the layers array using the callback\n\t\t\tfor (let l = 0; l < layers.length; l += 1) {\n\t\t\t\tconst layer = layers[l];\n\t\t\t\tif (callback.call(canvas, layer)) {\n\t\t\t\t\t// Add layer to array of matching layers if test passes\n\t\t\t\t\tmatching.push(layer);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// Otherwise, get all layers\n\n\t\t\tmatching = layers;\n\t\t}\n\t}\n\treturn matching;\n};\n\n// Get a single jCanvas layer object\n$.fn.getLayer = function getLayer(layerId) {\n\tconst $canvases = this;\n\n\tif ($canvases.length !== 0) {\n\t\tconst canvas = $canvases[0];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst layers = data.layers;\n\t\tconst idType = typeOf(layerId);\n\n\t\tif (\n\t\t\tlayerId &&\n\t\t\ttypeof layerId === \"object\" &&\n\t\t\t\"layer\" in layerId &&\n\t\t\tlayerId.layer\n\t\t) {\n\t\t\t// Return the actual layer object if given\n\t\t\treturn layerId;\n\t\t} else if (idType === \"number\") {\n\t\t\t// Retrieve the layer using the given index\n\n\t\t\tlet layerIndex = layerId as number;\n\n\t\t\t// Allow for negative indices\n\t\t\tif (layerIndex < 0) {\n\t\t\t\tlayerIndex = layers.length + layerIndex;\n\t\t\t}\n\t\t\t// Get layer with the given index\n\t\t\treturn layers[layerIndex];\n\t\t} else if (idType === \"regexp\") {\n\t\t\tconst layerPattern = layerId as RegExp;\n\t\t\t// Get layer with the name that matches the given regex\n\t\t\tfor (let l = 0; l < layers.length; l += 1) {\n\t\t\t\tconst layer = layers[l];\n\t\t\t\t// Check if layer matches name\n\t\t\t\tif (isString(layer.name) && layer.name.match(layerPattern)) {\n\t\t\t\t\treturn layer;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst layerName = layerId as string;\n\t\t\t// Get layer with the given name\n\t\t\treturn data.layer.names[layerName];\n\t\t}\n\t}\n};\n\n// Get all layers in the given group\n$.fn.getLayerGroup = function getLayerGroup(groupId) {\n\tconst $canvases = this;\n\tconst idType = typeOf(groupId);\n\n\tif ($canvases.length !== 0) {\n\t\tconst canvas = $canvases[0];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tif (idType === \"array\") {\n\t\t\t// Return layer group if given\n\t\t\treturn groupId as Exclude<typeof groupId, string | RegExp>;\n\t\t} else if (idType === \"regexp\") {\n\t\t\tconst groupPattern = groupId as RegExp;\n\t\t\t// Get canvas data\n\t\t\tconst data = _getCanvasData(canvas);\n\t\t\tconst groups = data.layer.groups;\n\t\t\t// Loop through all layers groups for this canvas\n\t\t\tfor (const groupName in groups) {\n\t\t\t\t// Find a group whose name matches the given regex\n\t\t\t\tif (groupName.match(groupPattern)) {\n\t\t\t\t\t// Stop after finding the first matching group\n\t\t\t\t\treturn groups[groupName];\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (typeof groupId === \"string\") {\n\t\t\t// Find layer group with the given group name\n\t\t\tconst groupName = groupId as string;\n\t\t\tconst data = _getCanvasData(canvas);\n\t\t\treturn data.layer.groups[groupName];\n\t\t}\n\t}\n};\n\n// Get index of layer in layers array\n$.fn.getLayerIndex = function getLayerIndex(layerId) {\n\tconst $canvases = this;\n\tconst layers = $canvases.getLayers();\n\tconst layer = $canvases.getLayer(layerId);\n\n\treturn inArray(layer, layers);\n};\n\n// Set properties of a layer\n$.fn.setLayer = function setLayer(layerId, props) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\n\t\tconst layer = $($canvases[e]).getLayer(layerId);\n\t\tif (layer) {\n\t\t\t// Update layer property maps\n\t\t\t_updateLayerName(data, layer, props);\n\t\t\t_updateLayerGroups(data, layer, props);\n\n\t\t\t_coerceNumericProps(props);\n\n\t\t\t// Merge properties with layer\n\t\t\tfor (const propName in props) {\n\t\t\t\tif (Object.prototype.hasOwnProperty.call(props, propName)) {\n\t\t\t\t\tconst propValue = props[propName as keyof typeof props];\n\t\t\t\t\tconst propType = typeOf(propValue);\n\t\t\t\t\tif (propType === \"object\" && isPlainObject(propValue)) {\n\t\t\t\t\t\t// Clone objects\n\t\t\t\t\t\tlayer[propName as any] = extendObject({}, propValue);\n\t\t\t\t\t\t_coerceNumericProps(layer[propName as keyof JCanvasLayer]);\n\t\t\t\t\t} else if (propType === \"array\") {\n\t\t\t\t\t\t// Clone arrays\n\t\t\t\t\t\tlayer[propName as any] = propValue.slice(0);\n\t\t\t\t\t} else if (propType === \"string\") {\n\t\t\t\t\t\tif (propValue.indexOf(\"+=\") === 0) {\n\t\t\t\t\t\t\t// Increment numbers prefixed with +=\n\t\t\t\t\t\t\tlayer[propName as any] += parseFloat(propValue.substr(2));\n\t\t\t\t\t\t} else if (propValue.indexOf(\"-=\") === 0) {\n\t\t\t\t\t\t\t// Decrement numbers prefixed with -=\n\t\t\t\t\t\t\tlayer[propName as any] -= parseFloat(propValue.substr(2));\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t!isNaN(propValue) &&\n\t\t\t\t\t\t\tisNumeric(propValue) &&\n\t\t\t\t\t\t\tpropName !== \"text\"\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t// Convert numeric values as strings to numbers\n\t\t\t\t\t\t\tlayer[propName as any] = parseFloat(String(propValue));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Otherwise, set given string value\n\t\t\t\t\t\t\tlayer[propName as any] = propValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Otherwise, set given value\n\t\t\t\t\t\tlayer[propName as any] = propValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update layer events\n\t\t\t_addLayerEvents($canvas, data, layer);\n\t\t\t_enableDrag($canvas, data, layer);\n\n\t\t\t// If layer's properties were changed\n\t\t\tif ($.isEmptyObject(props) === false) {\n\t\t\t\t_triggerLayerEvent($canvas, data, layer, \"change\", props);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Set properties of all layers (optionally filtered by a callback)\n$.fn.setLayers = function setLayers(props, callback) {\n\tconst $canvases = this;\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\n\t\tconst layers = $canvas.getLayers(callback);\n\t\t// Loop through all layers\n\t\tfor (let l = 0; l < layers.length; l += 1) {\n\t\t\t// Set properties of each layer\n\t\t\t$canvas.setLayer(layers[l], props);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Set properties of all layers in the given group\n$.fn.setLayerGroup = function setLayerGroup(groupId, props) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\t// Get layer group\n\t\tconst $canvas = $($canvases[e]);\n\n\t\tconst group = $canvas.getLayerGroup(groupId);\n\t\t// If group exists\n\t\tif (group) {\n\t\t\t// Loop through layers in group\n\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t// Merge given properties with layer\n\t\t\t\t$canvas.setLayer(group[l], props);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Move a layer to the given index in the layers array\n$.fn.moveLayer = function moveLayer(layerId, index) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\n\t\t// Retrieve layers array and desired layer\n\t\tconst layers = data.layers;\n\t\tconst layer = $canvas.getLayer(layerId);\n\t\tif (layer) {\n\t\t\t// Ensure layer index is accurate\n\t\t\tlayer.index = inArray(layer, layers);\n\n\t\t\t// Remove layer from its current placement\n\t\t\tlayers.splice(layer.index, 1);\n\t\t\t// Add layer in its new placement\n\t\t\tlayers.splice(index, 0, layer);\n\n\t\t\t// Handle negative indices\n\t\t\tif (index < 0) {\n\t\t\t\tindex = layers.length + index;\n\t\t\t}\n\t\t\t// Update layer's stored index\n\t\t\tlayer.index = index;\n\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"move\");\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Remove a jCanvas layer\n$.fn.removeLayer = function removeLayer(layerId) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\n\t\t// Retrieve layers array and desired layer\n\t\tconst layers = $canvas.getLayers();\n\t\tconst layer = $canvas.getLayer(layerId);\n\t\t// Remove layer if found\n\t\tif (layer) {\n\t\t\t// Ensure layer index is accurate\n\t\t\tlayer.index = inArray(layer, layers);\n\t\t\t// Remove layer and allow it to be re-added later\n\t\t\tlayers.splice(layer.index, 1);\n\t\t\tdelete layer._layer;\n\n\t\t\t// Update layer name map\n\t\t\t_updateLayerName(data, layer, {\n\t\t\t\tname: null,\n\t\t\t});\n\t\t\t// Update layer group map\n\t\t\t_updateLayerGroups(data, layer, {\n\t\t\t\tgroups: null,\n\t\t\t});\n\n\t\t\t// Trigger 'remove' event\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"remove\");\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Remove all layers\n$.fn.removeLayers = function removeLayers(callback) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst layers = $canvas.getLayers(callback).slice(0);\n\t\t// Remove all layers individually\n\t\tfor (let l = 0; l < layers.length; l += 1) {\n\t\t\t$canvas.removeLayer(layers[l]);\n\t\t}\n\t\t// Update layer maps\n\t\tdata.layer.names = {};\n\t\tdata.layer.groups = {};\n\t}\n\treturn $canvases;\n};\n\n// Remove all layers in the group with the given ID\n$.fn.removeLayerGroup = function removeLayerGroup(groupId) {\n\tconst $canvases = this;\n\n\tif (groupId !== undefined) {\n\t\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\t\tconst $canvas = $($canvases[e]);\n\n\t\t\tlet group = $canvas.getLayerGroup(groupId);\n\t\t\t// Remove layer group using given group name\n\t\t\tif (group) {\n\t\t\t\t// Clone groups array\n\t\t\t\tgroup = group.slice(0);\n\n\t\t\t\t// Loop through layers in group\n\t\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t\t$canvas.removeLayer(group[l]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Add an existing layer to a layer group\n$.fn.addLayerToGroup = function addLayerToGroup(layerId, groupName) {\n\tconst $canvases = this;\n\tlet groups = [groupName];\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\t\tconst layer = $canvas.getLayer(layerId);\n\n\t\t// If layer is not already in group\n\t\tif (layer?.groups) {\n\t\t\t// Clone groups list\n\t\t\tgroups = layer.groups.slice(0);\n\t\t\t// If layer is not already in group\n\t\t\tif (inArray(groupName, layer.groups) === -1) {\n\t\t\t\t// Add layer to group\n\t\t\t\tgroups.push(groupName);\n\t\t\t}\n\t\t}\n\t\t// Update layer group maps\n\t\t$canvas.setLayer(layer, {\n\t\t\tgroups: groups,\n\t\t});\n\t}\n\treturn $canvases;\n};\n\n// Remove an existing layer from a layer group\n$.fn.removeLayerFromGroup = function removeLayerFromGroup(layerId, groupName) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\t\tconst layer = $canvas.getLayer(layerId);\n\n\t\tif (layer?.groups) {\n\t\t\t// Find index of layer in group\n\t\t\tconst index = inArray(groupName, layer.groups);\n\n\t\t\t// If layer is in group\n\t\t\tif (index !== -1) {\n\t\t\t\t// Clone groups list\n\t\t\t\tconst groups = layer.groups.slice(0);\n\n\t\t\t\t// Remove layer from group\n\t\t\t\tgroups.splice(index, 1);\n\n\t\t\t\t// Update layer group maps\n\t\t\t\t$canvas.setLayer(layer, {\n\t\t\t\t\tgroups: groups,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Get topmost layer that intersects with event coordinates\nfunction _getIntersectingLayer(data: JCanvasInternalData) {\n\t// Store the topmost layer\n\tlet layer: JCanvasLayer | null = null;\n\tlet mask: JCanvasObject;\n\n\t// Get the topmost layer whose visible area intersects event coordinates\n\tfor (let i = data.intersecting.length - 1; i >= 0; i -= 1) {\n\t\t// Get current layer\n\t\tlayer = data.intersecting[i];\n\n\t\t// If layer has previous masks\n\t\tif (layer._masks) {\n\t\t\t// Search previous masks to ensure\n\t\t\t// layer is visible at event coordinates\n\t\t\tfor (let m = layer._masks.length - 1; m >= 0; m -= 1) {\n\t\t\t\tmask = layer._masks[m];\n\t\t\t\t// If mask does not intersect event coordinates\n\t\t\t\tif (!mask.intersects) {\n\t\t\t\t\t// Indicate that the mask does not\n\t\t\t\t\t// intersect event coordinates\n\t\t\t\t\tlayer.intersects = false;\n\t\t\t\t\t// Stop searching previous masks\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If event coordinates intersect all previous masks\n\t\t\t// and layer is not intangible\n\t\t\tif (layer.intersects && !layer.intangible) {\n\t\t\t\t// Stop searching for topmost layer\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t// If resulting layer is intangible\n\tif (layer?.intangible) {\n\t\t// Cursor does not intersect this layer\n\t\tlayer = null;\n\t}\n\treturn layer;\n}\n\n// Draw individual layer (internal)\nfunction _drawLayer(\n\t$canvas: JQuery,\n\tlayer: JCanvasLayer,\n\tnextLayerIndex?: number\n) {\n\tif (layer.visible && layer._method) {\n\t\tlayer._next = nextLayerIndex || null;\n\t\t// If layer is an object, call its respective method\n\t\tlayer._method?.call($canvas, layer);\n\t}\n}\n\n// Handle dragging of the currently-dragged layer\nfunction _handleLayerDrag(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData,\n\teventType: JCanvasInteractionEventName\n) {\n\tconst drag = data.drag;\n\tconst layer = drag.layer as JCanvasLayer;\n\tconst dragGroups = layer?.dragGroups || [];\n\tconst layers = data.layers;\n\n\tif (eventType === \"mousemove\" || eventType === \"touchmove\") {\n\t\t// Detect when user is currently dragging layer\n\n\t\tif (!drag.dragging) {\n\t\t\t// Detect when user starts dragging layer\n\n\t\t\t// Signify that a layer on the canvas is being dragged\n\t\t\tdrag.dragging = true;\n\t\t\tlayer.dragging = true;\n\n\t\t\t// Optionally bring layer to front when drag starts\n\t\t\tif (layer.bringToFront && layer.index !== null) {\n\t\t\t\t// Remove layer from its original position\n\t\t\t\tlayers.splice(layer.index, 1);\n\t\t\t\t// Bring layer to front\n\t\t\t\t// push() returns the new array length\n\t\t\t\tlayer.index = layers.push(layer);\n\t\t\t}\n\n\t\t\t// Set drag properties for this layer\n\t\t\tlayer._startX = layer.x;\n\t\t\tlayer._startY = layer.y;\n\t\t\tlayer._endX = layer._eventX;\n\t\t\tlayer._endY = layer._eventY;\n\n\t\t\t// Trigger dragstart event\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"dragstart\");\n\t\t}\n\n\t\tif (drag.dragging) {\n\t\t\t// Calculate position after drag\n\t\t\tlet newX = layer._eventX - (layer._endX - layer._startX);\n\t\t\tlet newY = layer._eventY - (layer._endY - layer._startY);\n\t\t\tif (layer.updateDragX) {\n\t\t\t\tnewX = layer.updateDragX.call($canvas[0], layer, newX);\n\t\t\t}\n\t\t\tif (layer.updateDragY) {\n\t\t\t\tnewY = layer.updateDragY.call($canvas[0], layer, newY);\n\t\t\t}\n\t\t\tlayer.dx = newX - layer.x;\n\t\t\tlayer.dy = newY - layer.y;\n\t\t\tif (layer.restrictDragToAxis !== \"y\") {\n\t\t\t\tlayer.x = newX;\n\t\t\t}\n\t\t\tif (layer.restrictDragToAxis !== \"x\") {\n\t\t\t\tlayer.y = newY;\n\t\t\t}\n\n\t\t\t// Trigger drag event\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"drag\");\n\n\t\t\t// Move groups with layer on drag\n\t\t\tfor (let g = 0; g < dragGroups.length; g += 1) {\n\t\t\t\tconst groupName = dragGroups[g];\n\t\t\t\tconst group = data.layer.groups[groupName];\n\t\t\t\tif (layer.groups && group) {\n\t\t\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t\t\tif (group[l] !== layer) {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlayer.restrictDragToAxis !== \"y\" &&\n\t\t\t\t\t\t\t\tgroup[l].restrictDragToAxis !== \"y\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tgroup[l].x += layer.dx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tlayer.restrictDragToAxis !== \"x\" &&\n\t\t\t\t\t\t\t\tgroup[l].restrictDragToAxis !== \"x\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tgroup[l].y += layer.dy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (eventType === \"mouseup\" || eventType === \"touchend\") {\n\t\t// Detect when user stops dragging layer\n\n\t\tif (drag.dragging) {\n\t\t\tlayer.dragging = false;\n\t\t\tdrag.dragging = false;\n\t\t\tdata.redrawOnMousemove = data.originalRedrawOnMousemove;\n\t\t\t// Trigger dragstop event\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"dragstop\");\n\t\t}\n\n\t\t// Cancel dragging\n\t\tdata.drag = {\n\t\t\tlayer: null,\n\t\t\tdragging: false,\n\t\t};\n\t}\n}\n\n// Set cursor on canvas\nfunction _setCursor(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tlayer: JCanvasLayer,\n\teventType: JCanvasInteractionEventName\n) {\n\tlet cursor;\n\tif (layer.cursors) {\n\t\t// Retrieve cursor from cursors object if it exists\n\t\tcursor = layer.cursors[eventType];\n\t}\n\t// If cursor is defined\n\tif (cursor) {\n\t\t// Set canvas cursor\n\t\t$canvas.css({\n\t\t\tcursor: cursor,\n\t\t});\n\t}\n}\n\n// Reset cursor on canvas\nfunction _resetCursor(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData\n) {\n\t$canvas.css({\n\t\tcursor: data.cursor,\n\t});\n}\n\n// Run the given event callback with the given arguments\nfunction _runEventCallback(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tlayer: JCanvasLayer,\n\teventType: string,\n\tcallbacks: any,\n\targ: any\n) {\n\t// Prevent callback from firing recursively\n\tif (callbacks[eventType] && layer._running && !layer._running[eventType]) {\n\t\t// Signify the start of callback execution for this event\n\t\tlayer._running[eventType] = true;\n\t\t// Run event callback with the given arguments\n\t\tcallbacks[eventType].call($canvas[0], layer, arg);\n\t\t// Signify the end of callback execution for this event\n\t\tlayer._running[eventType] = false;\n\t}\n}\n\n// Determine if the given layer can \"legally\" fire the given event\nfunction _layerCanFireEvent(\n\tlayer: JCanvasLayer,\n\teventType: string\n): eventType is JCanvasMouseEventName | JCanvasTouchEventName {\n\t// If events are disable and if\n\t// layer is tangible or event is not tangible\n\treturn (\n\t\t!layer.disableEvents &&\n\t\t(!layer.intangible || inArray(eventType, tangibleEvents) === -1)\n\t);\n}\n\n// Trigger the given event on the given layer\nfunction _triggerLayerEvent(\n\t$canvas: JQuery<HTMLCanvasElement>,\n\tdata: JCanvasInternalData,\n\tlayer: JCanvasLayer,\n\teventType: JCanvasEventName,\n\targ?: any\n) {\n\t// If layer can legally fire this event type\n\tif (_layerCanFireEvent(layer, eventType)) {\n\t\t// Do not set a custom cursor on layer mouseout\n\t\tif (eventType !== \"mouseout\") {\n\t\t\t// Update cursor if one is defined for this event\n\t\t\t_setCursor($canvas, layer, eventType);\n\t\t}\n\n\t\t// Trigger the user-defined event callback\n\t\t_runEventCallback($canvas, layer, eventType, layer, arg);\n\t\t// Trigger the canvas-bound event hook\n\t\t_runEventCallback($canvas, layer, eventType, data.eventHooks, arg);\n\t\t// Trigger the global event hook\n\t\t_runEventCallback($canvas, layer, eventType, jCanvas.eventHooks, arg);\n\t}\n}\n\n// Manually trigger a layer event\n$.fn.triggerLayerEvent = function (layerId, eventType) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst layer = $canvas.getLayer(layerId);\n\t\tif (layer) {\n\t\t\t// We need to type assert here because the developer may trigger a\n\t\t\t// custom event that is not inherently part of JCanvasEventName;\n\t\t\t// this is a use case we want to allow\n\t\t\t_triggerLayerEvent($canvas, data, layer, eventType as JCanvasEventName);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draw layer with the given ID\n$.fn.drawLayer = function drawLayer(layerId) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst layer = $canvas.getLayer(layerId);\n\t\tif (layer) {\n\t\t\t_drawLayer($canvas, layer);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Draw all layers (or, if given, only layers starting at an index)\n$.fn.drawLayers = function drawLayers(args) {\n\tconst $canvases = this;\n\t// Internal parameters for redrawing the canvas\n\tconst params = args || {};\n\t// Other variables\n\tlet isImageLayer: boolean = false;\n\n\t// The layer index from which to start redrawing the canvas\n\tconst index = params.index || 0;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\t// Clear canvas first unless otherwise directed\n\t\tif (params.clear !== false) {\n\t\t\t$canvas.clearCanvas();\n\t\t}\n\n\t\t// If a completion callback was provided, save it to the canvas data\n\t\t// store so that the function can be passed to drawLayers() again\n\t\t// after any image layers have loaded\n\t\tif (params.complete) {\n\t\t\tdata.drawLayersComplete = params.complete;\n\t\t}\n\n\t\t// Cache the layers array\n\t\tconst layers = data.layers;\n\n\t\t// Draw layers from first to last (bottom to top)\n\t\tlet l;\n\t\tfor (l = index; l < layers.length; l += 1) {\n\t\t\tconst layer = layers[l];\n\n\t\t\t// Ensure layer index is up-to-date\n\t\t\tlayer.index = l;\n\n\t\t\t// Prevent any one event from firing excessively\n\t\t\tif (params.resetFire) {\n\t\t\t\tlayer._fired = false;\n\t\t\t}\n\t\t\t// Draw layer\n\t\t\t_drawLayer($canvas, layer, l + 1);\n\t\t\t// Store list of previous masks for each layer\n\t\t\tlayer._masks = data.transforms.masks.slice(0);\n\n\t\t\t// Allow image layers to load before drawing successive layers\n\t\t\tif (layer._method === $.fn.drawImage && layer.visible) {\n\t\t\t\tisImageLayer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// If layer is an image layer\n\t\tif (isImageLayer) {\n\t\t\t// Stop and wait for drawImage() to resume drawLayers()\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Store the latest\n\t\tconst lastIndex = l;\n\n\t\t// Run completion callback (if provided) once all layers have drawn\n\t\tif (params.complete) {\n\t\t\tparams.complete.call($canvases[e]);\n\t\t\tdelete data.drawLayersComplete;\n\t\t}\n\n\t\t// Get first layer that intersects with event coordinates\n\t\tconst layer = _getIntersectingLayer(data);\n\n\t\tconst eventCache = data.event;\n\t\tlet eventType = eventCache.type;\n\n\t\t// If jCanvas has detected a dragstart\n\t\tif (data.drag.layer && eventType) {\n\t\t\t// Handle dragging of layer\n\t\t\t_handleLayerDrag($canvas, data, eventType);\n\t\t}\n\n\t\t// Manage mouseout event\n\t\tconst lastLayer = data.lastIntersected;\n\t\tif (\n\t\t\tlastLayer !== null &&\n\t\t\tlayer !== lastLayer &&\n\t\t\tlastLayer._hovered &&\n\t\t\t!lastLayer._fired &&\n\t\t\t!data.drag.dragging\n\t\t) {\n\t\t\tdata.lastIntersected = null;\n\t\t\tlastLayer._fired = true;\n\t\t\tlastLayer._hovered = false;\n\t\t\t_triggerLayerEvent($canvas, data, lastLayer, \"mouseout\");\n\t\t\t_resetCursor($canvas, data);\n\t\t}\n\n\t\tif (layer && eventType) {\n\t\t\t// Use mouse event callbacks if no touch event callbacks are given\n\t\t\tif (!layer[eventType as keyof JCanvasLayer]) {\n\t\t\t\teventType = _getMouseEventName(eventType);\n\t\t\t}\n\n\t\t\t// Check events for intersecting layer\n\t\t\tif (layer._event && layer.intersects) {\n\t\t\t\tdata.lastIntersected = layer;\n\n\t\t\t\t// Detect mouseover events\n\t\t\t\tif (\n\t\t\t\t\t(layer.mouseover || layer.mouseout || layer.cursors) &&\n\t\t\t\t\t!data.drag.dragging\n\t\t\t\t) {\n\t\t\t\t\tif (!layer._hovered && !layer._fired) {\n\t\t\t\t\t\t// Prevent events from firing excessively\n\t\t\t\t\t\tlayer._fired = true;\n\t\t\t\t\t\tlayer._hovered = true;\n\t\t\t\t\t\t_triggerLayerEvent($canvas, data, layer, \"mouseover\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Detect any other mouse event\n\t\t\t\tif (!layer._fired) {\n\t\t\t\t\t// Prevent event from firing twice unintentionally\n\t\t\t\t\tlayer._fired = true;\n\t\t\t\t\teventCache.type = null;\n\n\t\t\t\t\t_triggerLayerEvent($canvas, data, layer, eventType);\n\t\t\t\t}\n\n\t\t\t\t// Use the mousedown event to start drag\n\t\t\t\tif (\n\t\t\t\t\tlayer.draggable &&\n\t\t\t\t\t!layer.disableEvents &&\n\t\t\t\t\t(eventType === \"mousedown\" || eventType === \"touchstart\")\n\t\t\t\t) {\n\t\t\t\t\t// Keep track of drag state\n\t\t\t\t\tdata.drag.layer = layer;\n\t\t\t\t\tdata.originalRedrawOnMousemove = data.redrawOnMousemove;\n\t\t\t\t\tdata.redrawOnMousemove = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If cursor is not intersecting with any layer\n\t\t\tif (layer === null && !data.drag.dragging) {\n\t\t\t\t// Reset cursor to previous state\n\t\t\t\t_resetCursor($canvas, data);\n\t\t\t}\n\n\t\t\t// If the last layer has been drawn\n\t\t\tif (lastIndex === layers.length) {\n\t\t\t\t// Reset list of intersecting layers\n\t\t\t\tdata.intersecting.length = 0;\n\t\t\t\t// Reset transformation stack\n\t\t\t\tdata.transforms = _cloneTransforms(baseTransforms);\n\t\t\t\tdata.savedTransforms.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Add a jCanvas layer (internal)\nfunction _addLayer(\n\tcanvas: HTMLCanvasElement,\n\tparams: JCanvasObject,\n\targs?: Partial<JCanvasObject>,\n\tmethod?: (_args: JCanvasObject) => JQuery<HTMLElement>\n): JCanvasObject {\n\tconst layer: JCanvasObject = params._layer ? (args as JCanvasLayer) : params;\n\n\t// Store arguments object for later use\n\tparams._args = args;\n\n\t// Convert all draggable drawings into jCanvas layers\n\tif (params.draggable || params.dragGroups) {\n\t\tparams.layer = true;\n\t\tparams.draggable = true;\n\t}\n\n\t// Determine the layer's type using the available information\n\tif (!params._method) {\n\t\tif (method) {\n\t\t\tparams._method = method;\n\t\t} else if (params.method) {\n\t\t\tparams._method = $.fn[params.method];\n\t\t} else if (params.type) {\n\t\t\tparams._method = $.fn[maps.drawings[params.type] as keyof JQuery];\n\t\t}\n\t}\n\n\t// If layer hasn't been added yet\n\tif (params.layer && !params._layer && layer) {\n\t\t// Add layer to canvas\n\n\t\tconst $canvas = $(canvas);\n\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst layers = data.layers;\n\n\t\t// Do not add duplicate layers of same name\n\t\tif (\n\t\t\tlayer.name === null ||\n\t\t\t(isString(layer.name) && data.layer.names[layer.name] === undefined)\n\t\t) {\n\t\t\t// Convert number properties to numbers\n\t\t\t_coerceNumericProps(params);\n\n\t\t\t// Ensure layers are unique across canvases by cloning them\n\t\t\tconst newLayer = new jCanvasLayer(canvas, params);\n\t\t\tnewLayer.canvas = canvas;\n\t\t\t// Indicate that this is a layer for future checks\n\t\t\tnewLayer.layer = true;\n\t\t\tnewLayer._layer = true;\n\t\t\tnewLayer._running = {};\n\t\t\t// If layer stores user-defined data\n\t\t\tif (newLayer.data !== null) {\n\t\t\t\t// Clone object\n\t\t\t\tnewLayer.data = extendObject({}, newLayer.data);\n\t\t\t} else {\n\t\t\t\t// Otherwise, create data object\n\t\t\t\tnewLayer.data = {};\n\t\t\t}\n\t\t\t// If layer stores a list of associated groups\n\t\t\tif (newLayer.groups) {\n\t\t\t\t// Clone list\n\t\t\t\tnewLayer.groups = newLayer.groups.slice(0);\n\t\t\t} else {\n\t\t\t\t// Otherwise, create empty list\n\t\t\t\tnewLayer.groups = [];\n\t\t\t}\n\n\t\t\t// Update layer group maps\n\t\t\t_updateLayerName(data, newLayer);\n\t\t\t_updateLayerGroups(data, newLayer);\n\n\t\t\t// Check for any associated jCanvas events and enable them\n\t\t\t_addLayerEvents($canvas, data, newLayer);\n\n\t\t\t// Optionally enable drag-and-drop support and cursor support\n\t\t\t_enableDrag($canvas, data, newLayer);\n\n\t\t\t// Copy _event property to parameters object\n\t\t\tparams._event = newLayer._event;\n\n\t\t\t// Calculate width/height for text layers\n\t\t\tif (newLayer._method === $.fn.drawText) {\n\t\t\t\t$canvas.measureText(newLayer);\n\t\t\t}\n\n\t\t\t// Add layer to end of array if no index is specified\n\t\t\tif (newLayer.index === null) {\n\t\t\t\tnewLayer.index = layers.length;\n\t\t\t}\n\n\t\t\t// Add layer to layers array at specified index\n\t\t\tlayers.splice(newLayer.index, 0, newLayer);\n\n\t\t\t// Store layer on parameters object\n\t\t\tparams._args = newLayer;\n\n\t\t\t// Trigger an 'add' event\n\t\t\t_triggerLayerEvent($canvas, data, newLayer, \"add\");\n\t\t\treturn newLayer;\n\t\t}\n\t} else if (!params.layer) {\n\t\t_coerceNumericProps(params);\n\t}\n\n\treturn layer;\n}\n\n// Add a jCanvas layer\n$.fn.addLayer = function addLayer(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\tparams.layer = true;\n\t\t_addLayer(canvas, params, args);\n\t}\n\treturn $canvases;\n};\n\n/* Animation API */\n\n// Hide/show jCanvas/CSS properties so they can be animated using jQuery\nfunction _showProps(obj: Partial<JCanvasObject>) {\n\tfor (let p = 0; p < css.props.length; p += 1) {\n\t\tconst cssProp = css.props[p];\n\t\tobj[cssProp as keyof typeof obj] = obj[(\"_\" + cssProp) as `_${string}`];\n\t}\n}\nfunction _hideProps(obj: Partial<JCanvasObject>, reset?: boolean) {\n\tfor (let p = 0; p < css.props.length; p += 1) {\n\t\tconst cssProp = css.props[p];\n\t\t// Hide property using same name with leading underscore\n\t\tif (obj[cssProp as keyof typeof obj] !== undefined) {\n\t\t\tobj[(\"_\" + cssProp) as `_${string}`] = obj[cssProp as keyof typeof obj];\n\t\t\tcss.propsObj[cssProp] = true;\n\t\t\tif (reset) {\n\t\t\t\tdelete obj[cssProp as keyof typeof obj];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Evaluate property values that are functions\nfunction _parseEndValues(\n\tcanvas: HTMLCanvasElement,\n\tlayer: JCanvasLayer,\n\tendValues: Record<string, any>\n) {\n\t// Loop through all properties in map of end values\n\tfor (const propName in endValues) {\n\t\tif (Object.prototype.hasOwnProperty.call(endValues, propName)) {\n\t\t\tconst propValue = endValues[propName];\n\t\t\t// If end value is function\n\t\t\tif (isFunction(propValue)) {\n\t\t\t\t// Call function and use its value as the end value\n\t\t\t\tendValues[propName] = propValue.call(canvas, layer, propName);\n\t\t\t}\n\t\t\t// If end value is an object\n\t\t\tif (typeOf(propValue) === \"object\" && isPlainObject(propValue)) {\n\t\t\t\t// Prepare to animate properties in object\n\t\t\t\tfor (const subPropName in propValue) {\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(propValue, subPropName)) {\n\t\t\t\t\t\tconst subPropValue = propValue[subPropName];\n\t\t\t\t\t\t// Store property's start value at top-level of layer\n\t\t\t\t\t\tif (layer[propName as keyof JCanvasLayer] !== undefined) {\n\t\t\t\t\t\t\tlayer[(propName + \".\" + subPropName) as any] =\n\t\t\t\t\t\t\t\tlayer[propName as keyof JCanvasLayer][subPropName];\n\t\t\t\t\t\t\t// Store property's end value at top-level of end values map\n\t\t\t\t\t\t\tendValues[propName + \".\" + subPropName] = subPropValue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Delete sub-property of object as it's no longer needed\n\t\t\t\tdelete endValues[propName];\n\t\t\t}\n\t\t}\n\t}\n\treturn endValues;\n}\n\n// Remove sub-property aliases from layer object\nfunction _removeSubPropAliases(layer: JCanvasLayer) {\n\tfor (const propName in layer) {\n\t\tif (Object.prototype.hasOwnProperty.call(layer, propName)) {\n\t\t\tif (propName.indexOf(\".\") !== -1) {\n\t\t\t\tdelete layer[propName as keyof JCanvasLayer];\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Convert the given color to a normalized RGB/RGBA color string\nfunction _normalizeColor(color: string) {\n\tif (color === \"transparent\") {\n\t\t// Deal with complete transparency\n\t\treturn \"rgba(0, 0, 0, 0)\";\n\t} else if (color.match(/^([a-z]+|#[0-9a-f]+)$/gi)) {\n\t\t// Deal with hexadecimal colors and color names (note: element must be\n\t\t// in the DOM for this to work consistently)\n\t\tconst headElem = document.head;\n\t\tconst originalColor = headElem.style.color;\n\t\theadElem.style.color = color;\n\t\tconst normalizedColor = $.css(headElem, \"color\");\n\t\theadElem.style.color = originalColor;\n\t\treturn normalizedColor;\n\t} else {\n\t\treturn color;\n\t}\n}\n\n// Convert a color value to an array of RGB values\nfunction _convertColorToRgbArray(color: string) {\n\tconst normalizedColor: string = _normalizeColor(color);\n\t// Parse RGB string\n\tif (/^rgb/gi.test(normalizedColor)) {\n\t\tconst rgbMatches: string[] = normalizedColor.match(/(\\d+(\\.\\d+)?)/gi) || [];\n\t\t// Deal with RGB percentages\n\t\tconst multiple = /%/gi.test(normalizedColor) ? 2.55 : 1;\n\t\treturn [\n\t\t\tNumber(rgbMatches[0]) * multiple,\n\t\t\tNumber(rgbMatches[1]) * multiple,\n\t\t\tNumber(rgbMatches[2]) * multiple,\n\t\t\trgbMatches[3] ? Number(rgbMatches[3]) * multiple : 1,\n\t\t];\n\t} else {\n\t\tconsole.error(`Color format unsupported: ${normalizedColor}`);\n\t\treturn [];\n\t}\n}\n\n// Blend two colors by the given percentage\nfunction _blendColors(color1: string, color2: string, percentage: number) {\n\tconst [r1, g1, b1, a1] = _convertColorToRgbArray(color1);\n\tconst [r2, g2, b2, a2] = _convertColorToRgbArray(color2);\n\n\tconst r = round(r1 + (r2 - r1) * percentage);\n\tconst g = round(g1 + (g2 - g1) * percentage);\n\tconst b = round(b1 + (b2 - b1) * percentage);\n\tconst a = a1 + (a2 - a1) * percentage;\n\n\treturn `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\n// Animate jCanvas layer\n$.fn.animateLayer = function animateLayer(...args) {\n\tconst $canvases = this;\n\n\t// Deal with all cases of argument placement\n\t/*\n\t\t0. layer name/index\n\t\t1. properties\n\t\t2. duration/options\n\t\t3. easing\n\t\t4. complete function\n\t\t5. step function\n\t*/\n\n\tif (!args.length) {\n\t\treturn $canvases;\n\t}\n\n\tif (typeOf(args[2]) === \"object\") {\n\t\t// Accept an options object for animation\n\t\targs.splice(2, 0, args[2].duration || null);\n\t\targs.splice(3, 0, args[3].easing || null);\n\t\targs.splice(4, 0, args[4].complete || null);\n\t\targs.splice(5, 0, args[5].step || null);\n\t} else {\n\t\tif (args[2] === undefined) {\n\t\t\t// If object is the last argument\n\t\t\targs.splice(2, 0, null);\n\t\t\targs.splice(3, 0, null);\n\t\t\targs.splice(4, 0, null);\n\t\t} else if (isFunction(args[2])) {\n\t\t\t// If callback comes after object\n\t\t\targs.splice(2, 0, null);\n\t\t\targs.splice(3, 0, null);\n\t\t}\n\t\tif (args[3] === undefined) {\n\t\t\t// If duration is the last argument\n\t\t\targs[3] = null;\n\t\t\targs.splice(4, 0, null);\n\t\t} else if (isFunction(args[3])) {\n\t\t\t// If callback comes after duration\n\t\t\targs.splice(3, 0, null);\n\t\t}\n\t}\n\n\t// Run callback function when animation completes\n\tfunction complete(\n\t\t$canvas: JQuery<HTMLCanvasElement>,\n\t\tdata: JCanvasInternalData,\n\t\tlayer: JCanvasLayer\n\t) {\n\t\treturn function () {\n\t\t\t_showProps(layer);\n\t\t\t_removeSubPropAliases(layer);\n\n\t\t\t// Prevent multiple redraw loops\n\t\t\tif (!data.animating || data.animated === layer) {\n\t\t\t\t// Redraw layers on last frame\n\t\t\t\t$canvas.drawLayers();\n\t\t\t}\n\n\t\t\t// Signify the end of an animation loop\n\t\t\tlayer._animating = false;\n\t\t\tdata.animating = false;\n\t\t\tdata.animated = null;\n\n\t\t\t// If callback is defined\n\t\t\tif (args[4]) {\n\t\t\t\t// Run callback at the end of the animation\n\t\t\t\targs[4].call($canvas[0], layer);\n\t\t\t}\n\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"animateend\");\n\t\t};\n\t}\n\n\t// Redraw layers on every frame of the animation\n\tfunction step(\n\t\t$canvas: JQuery<HTMLCanvasElement>,\n\t\tdata: JCanvasInternalData,\n\t\tlayer: JCanvasLayer\n\t) {\n\t\treturn function (now: any, fx: any) {\n\t\t\tlet parts,\n\t\t\t\tpropName,\n\t\t\t\tsubPropName,\n\t\t\t\thidden = false;\n\n\t\t\t// If animated property has been hidden\n\t\t\tif (fx.prop[0] === \"_\") {\n\t\t\t\thidden = true;\n\t\t\t\t// Unhide property temporarily\n\t\t\t\tfx.prop = fx.prop.replace(\"_\", \"\");\n\t\t\t\tlayer[fx.prop] = layer[(\"_\" + fx.prop) as keyof JCanvasLayer];\n\t\t\t}\n\n\t\t\t// If animating property of sub-object\n\t\t\tif (fx.prop.indexOf(\".\") !== -1) {\n\t\t\t\tparts = fx.prop.split(\".\");\n\t\t\t\tpropName = parts[0];\n\t\t\t\tsubPropName = parts[1];\n\t\t\t\tif (layer[propName as keyof JCanvasLayer]) {\n\t\t\t\t\tlayer[propName as keyof JCanvasLayer][subPropName] = fx.now;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Throttle animation to improve efficiency\n\t\t\tif (layer._pos !== fx.pos) {\n\t\t\t\tlayer._pos = fx.pos;\n\n\t\t\t\t// Signify the start of an animation loop\n\t\t\t\tif (!layer._animating && !data.animating) {\n\t\t\t\t\tlayer._animating = true;\n\t\t\t\t\tdata.animating = true;\n\t\t\t\t\tdata.animated = layer;\n\t\t\t\t}\n\n\t\t\t\t// Prevent multiple redraw loops\n\t\t\t\tif (!data.animating || data.animated === layer) {\n\t\t\t\t\t// Redraw layers for every frame\n\t\t\t\t\t$canvas.drawLayers();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If callback is defined\n\t\t\tif (args[5]) {\n\t\t\t\t// Run callback for each step of animation\n\t\t\t\targs[5].call($canvas[0], now, fx, layer);\n\t\t\t}\n\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"animate\", fx);\n\n\t\t\t// If property should be hidden during animation\n\t\t\tif (hidden) {\n\t\t\t\t// Hide property again\n\t\t\t\tfx.prop = \"_\" + fx.prop;\n\t\t\t}\n\t\t};\n\t}\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\t// If a layer object was passed, use it the layer to be animated\n\t\tconst layer = $canvas.getLayer(args[0]);\n\n\t\t// Ignore layers that are functions\n\t\tif (layer && layer._method !== $.fn.draw) {\n\t\t\t// Do not modify original object\n\t\t\tconst props = _parseEndValues(canvas, layer, extendObject({}, args[1]));\n\n\t\t\t// Bypass jQuery CSS Hooks for CSS properties (width, opacity, etc.)\n\t\t\t_hideProps(props, true);\n\t\t\t_hideProps(layer);\n\n\t\t\t// Fix for jQuery's vendor prefixing support, which affects how width/height/opacity are animated\n\t\t\tlayer.style = css.propsObj;\n\n\t\t\t// Animate layer\n\t\t\t$(layer).animate(props, {\n\t\t\t\tduration: args[2],\n\t\t\t\teasing: $.easing[args[3]] ? args[3] : null,\n\t\t\t\t// When animation completes\n\t\t\t\tcomplete: complete($canvas, data, layer),\n\t\t\t\t// Redraw canvas for every animation frame\n\t\t\t\tstep: step($canvas, data, layer),\n\t\t\t});\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"animatestart\");\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Animate all layers in a layer group\n$.fn.animateLayerGroup = function animateLayerGroup(groupId, props, ...args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\t\tconst group = $canvas.getLayerGroup(groupId);\n\t\tif (group) {\n\t\t\t// Animate all layers in the group\n\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t// Replace first argument with layer\n\t\t\t\targs[0] = group[l];\n\t\t\t\t$canvas.animateLayer.apply($canvas, [props, ...args]);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Delay layer animation by a given number of milliseconds\n$.fn.delayLayer = function delayLayer(layerId, duration) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst layer = $canvas.getLayer(layerId);\n\t\t// If layer exists\n\t\tif (layer) {\n\t\t\t// Delay animation\n\t\t\t$(layer).delay(duration || 0);\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"delay\");\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Delay animation all layers in a layer group\n$.fn.delayLayerGroup = function delayLayerGroup(groupId, duration) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\n\t\tconst group = $canvas.getLayerGroup(groupId);\n\t\t// Delay all layers in the group\n\t\tif (group) {\n\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t// Delay each layer in the group\n\t\t\t\t$canvas.delayLayer(group[l], duration || 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Stop layer animation\n$.fn.stopLayer = function stopLayer(layerId, clearQueue) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst $canvas = $(canvas);\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst layer = $canvas.getLayer(layerId);\n\t\t// If layer exists\n\t\tif (layer) {\n\t\t\t// Stop animation\n\t\t\t$(layer).stop(clearQueue);\n\t\t\t_triggerLayerEvent($canvas, data, layer, \"stop\");\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Stop animation of all layers in a layer group\n$.fn.stopLayerGroup = function stopLayerGroup(groupId, clearQueue) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst $canvas = $($canvases[e]);\n\n\t\tconst group = $canvas.getLayerGroup(groupId);\n\t\t// Stop all layers in the group\n\t\tif (group) {\n\t\t\tfor (let l = 0; l < group.length; l += 1) {\n\t\t\t\t// Stop each layer in the group\n\t\t\t\tconst layer = group[l];\n\t\t\t\t$canvas.stopLayer(layer, clearQueue);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Enable animation for color properties\nfunction _supportColorProps(props: string[]) {\n\tfor (let p = 0; p < props.length; p += 1) {\n\t\t($.Tween.propHooks as JCanvasPropHooks)[props[p]] = {\n\t\t\tget: function (tween) {\n\t\t\t\treturn tween.elem[tween.prop as keyof typeof tween.elem];\n\t\t\t},\n\t\t\tset: function (tween) {\n\t\t\t\ttween.elem[tween.prop as any] = _blendColors(\n\t\t\t\t\ttween.start as any,\n\t\t\t\t\ttween.end as any,\n\t\t\t\t\ttween.pos || 0\n\t\t\t\t);\n\t\t\t},\n\t\t};\n\t}\n}\n\n// Enable animation for color properties\n_supportColorProps([\n\t\"color\",\n\t\"backgroundColor\",\n\t\"borderColor\",\n\t\"borderTopColor\",\n\t\"borderRightColor\",\n\t\"borderBottomColor\",\n\t\"borderLeftColor\",\n\t\"fillStyle\",\n\t\"outlineColor\",\n\t\"strokeStyle\",\n\t\"shadowColor\",\n]);\n\n/* Event API */\n\n// Convert mouse event name to a corresponding touch event name (if possible)\nfunction _getTouchEventName(eventName: JCanvasInteractionEventName) {\n\tconst touchEventName = maps.touchEvents[eventName];\n\tif (touchEventName) {\n\t\treturn touchEventName;\n\t}\n\treturn eventName;\n}\n// Convert touch event name to a corresponding mouse event name\nfunction _getMouseEventName(eventName: JCanvasInteractionEventName) {\n\tconst mouseEventName = maps.mouseEvents[eventName];\n\tif (mouseEventName) {\n\t\treturn mouseEventName;\n\t}\n\treturn eventName;\n}\n\n// Bind event to jCanvas layer using standard jQuery events\nfunction _createEvent(eventName: JCanvasInteractionEventName) {\n\tjCanvas.events[eventName] = function ($canvas, data) {\n\t\t// Retrieve canvas's event cache\n\t\tconst eventCache = data.event;\n\n\t\t// Both mouseover/mouseout events will be managed by a single mousemove event\n\t\tconst helperEventName =\n\t\t\teventName === \"mouseover\" || eventName === \"mouseout\"\n\t\t\t\t? \"mousemove\"\n\t\t\t\t: eventName;\n\t\tconst touchEventName = _getTouchEventName(helperEventName);\n\n\t\tfunction eventCallback(event: MouseEvent) {\n\t\t\t// Cache current mouse position and redraw layers\n\t\t\teventCache.x = event.offsetX;\n\t\t\teventCache.y = event.offsetY;\n\t\t\teventCache.type = helperEventName;\n\t\t\teventCache.event = event;\n\t\t\t// Redraw layers on every trigger of the event; don't redraw if at\n\t\t\t// least one layer is draggable and there are no layers with\n\t\t\t// explicit mouseover/mouseout/mousemove events\n\t\t\tif (\n\t\t\t\tevent.type !== \"mousemove\" ||\n\t\t\t\tdata.redrawOnMousemove ||\n\t\t\t\tdata.drag.dragging\n\t\t\t) {\n\t\t\t\t$canvas.drawLayers({\n\t\t\t\t\tresetFire: true,\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Prevent default event behavior\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\t// Ensure the event is not bound more than once\n\t\tif (!data.events[helperEventName]) {\n\t\t\t// Bind one canvas event which handles all layer events of that type\n\t\t\tif (touchEventName !== helperEventName) {\n\t\t\t\t$canvas.on(\n\t\t\t\t\thelperEventName + \".jCanvas \" + touchEventName + \".jCanvas\",\n\t\t\t\t\teventCallback as JQuery.EventHandlerBase<HTMLElement, object>\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\t$canvas.on(\n\t\t\t\t\thelperEventName + \".jCanvas\",\n\t\t\t\t\teventCallback as JQuery.EventHandlerBase<HTMLElement, object>\n\t\t\t\t);\n\t\t\t}\n\t\t\t// Prevent this event from being bound twice\n\t\t\tdata.events[helperEventName] = true;\n\t\t}\n\t};\n}\nfunction _createEvents(eventNames: JCanvasInteractionEventName[]) {\n\tfor (let n = 0; n < eventNames.length; n += 1) {\n\t\t_createEvent(eventNames[n]);\n\t}\n}\n// Populate jCanvas events object with some standard events\n_createEvents([\n\t\"click\",\n\t\"dblclick\",\n\t\"mousedown\",\n\t\"mouseup\",\n\t\"mousemove\",\n\t\"mouseover\",\n\t\"mouseout\",\n\t\"touchstart\",\n\t\"touchmove\",\n\t\"touchend\",\n\t\"pointerdown\",\n\t\"pointermove\",\n\t\"pointerup\",\n\t\"contextmenu\",\n]);\n\n// Check if event fires when a drawing is drawn\nfunction _detectEvents(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject\n) {\n\t// Use the layer object stored by the given parameters object\n\tconst layer = params._args;\n\t// Canvas must have event bindings\n\tif (layer) {\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst eventCache = data.event;\n\t\tlet intersects: boolean = false;\n\t\tlet x: number;\n\t\tlet y: number;\n\t\tif (eventCache.x !== null && eventCache.y !== null) {\n\t\t\t// Respect user-defined pixel ratio\n\t\t\tx = eventCache.x * data.pixelRatio;\n\t\t\ty = eventCache.y * data.pixelRatio;\n\t\t\t// Determine if the given coordinates are in the current path\n\t\t\tif (layer._path) {\n\t\t\t\tintersects =\n\t\t\t\t\tctx.isPointInPath(layer._path, x, y) ||\n\t\t\t\t\tctx.isPointInStroke(layer._path, x, y);\n\t\t\t} else {\n\t\t\t\tintersects = ctx.isPointInPath(x, y) || ctx.isPointInStroke(x, y);\n\t\t\t}\n\t\t}\n\t\tconst transforms = data.transforms;\n\n\t\t// Allow callback functions to retrieve the mouse coordinates\n\t\tlayer.eventX = eventCache.x;\n\t\tlayer.eventY = eventCache.y;\n\t\tlayer.event = eventCache.event;\n\n\t\t// Adjust coordinates to match current canvas transformation\n\n\t\t// Keep track of some transformation values\n\t\tconst angle = data.transforms.rotate;\n\t\tx = layer.eventX;\n\t\ty = layer.eventY;\n\n\t\tif (angle !== 0) {\n\t\t\t// Rotate coordinates if coordinate space has been rotated\n\t\t\tlayer._eventX = x * cos(-angle) - y * sin(-angle);\n\t\t\tlayer._eventY = y * cos(-angle) + x * sin(-angle);\n\t\t} else {\n\t\t\t// Otherwise, no calculations need to be made\n\t\t\tlayer._eventX = x;\n\t\t\tlayer._eventY = y;\n\t\t}\n\n\t\t// Scale coordinates\n\t\tlayer._eventX /= transforms.scaleX;\n\t\tlayer._eventY /= transforms.scaleY;\n\n\t\t// If layer intersects with cursor\n\t\tif (intersects) {\n\t\t\t// Add it to a list of layers that intersect with cursor\n\t\t\tdata.intersecting.push(layer);\n\t\t}\n\t\tlayer.intersects = Boolean(intersects);\n\t}\n}\n\n// Normalize offsetX and offsetY for all browsers\n// @ts-expect-error TODO: properly type extension for $.event\n$.event.fix = function (event) {\n\tevent = jQueryEventFix.call($.event, event);\n\tconst originalEvent = event.originalEvent;\n\n\t// originalEvent does not exist for manually-triggered events\n\tif (originalEvent) {\n\t\tconst touches = originalEvent.changedTouches;\n\n\t\t// If offsetX and offsetY are not supported, define them\n\t\tlet offset: JQuery.Coordinates | undefined;\n\t\tif (event.pageX !== undefined && event.offsetX === undefined) {\n\t\t\ttry {\n\t\t\t\toffset = $(event.currentTarget).offset();\n\t\t\t\tif (offset) {\n\t\t\t\t\tevent.offsetX = event.pageX - offset.left;\n\t\t\t\t\tevent.offsetY = event.pageY - offset.top;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Fail silently\n\t\t\t}\n\t\t} else if (touches) {\n\t\t\ttry {\n\t\t\t\t// Enable offsetX and offsetY for mobile devices\n\t\t\t\toffset = $(event.currentTarget).offset();\n\t\t\t\tif (offset) {\n\t\t\t\t\tevent.offsetX = touches[0].pageX - offset.left;\n\t\t\t\t\tevent.offsetY = touches[0].pageY - offset.top;\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\t// Fail silently\n\t\t\t}\n\t\t}\n\t}\n\treturn event;\n};\n\n/* Drawing API */\n\n// Draws on canvas using a function\n$.fn.draw = function draw(args) {\n\tconst $canvases = this;\n\tconst params = _getParamsObject(args);\n\n\t// Draw using any other method\n\tconst fn = $.fn[maps.drawings[params.type!] as keyof JQuery];\n\tif (params.type && maps.drawings[params.type] && isFunction(fn)) {\n\t\t// @ts-expect-error TODO (not sure how to fix this: \"This expression is\n\t\t// not callable. Each member of the union type '...' has signatures, but\n\t\t// none of those signatures are compatible with each other.\")\n\t\tfn.call($canvases, args);\n\t} else {\n\t\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\t\tconst canvas = $canvases[e];\n\t\t\tif (!_isCanvas(canvas)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst ctx = _getContext(canvas);\n\t\t\tif (!ctx) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst params = _getParamsObject(args);\n\t\t\t_addLayer(canvas, params, args, draw);\n\t\t\tif (!params.visible) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (params.fn) {\n\t\t\t\t// Call the given user-defined function\n\t\t\t\tparams.fn.call($canvases[e], ctx, params);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Clears canvas\n$.fn.clearCanvas = function clearCanvas(args) {\n\tconst $canvases = this;\n\tconst params = _getParamsObject(args);\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (params.width === null || params.height === null) {\n\t\t\t// Clear entire canvas if width/height is not given\n\n\t\t\t// Reset current transformation temporarily to ensure that the entire canvas is cleared\n\t\t\tctx.save();\n\t\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\n\t\t\tctx.clearRect(0, 0, canvas.width, canvas.height);\n\t\t\tctx.restore();\n\t\t} else {\n\t\t\t// Otherwise, clear the defined section of the canvas\n\n\t\t\t// Transform clear rectangle\n\t\t\t_addLayer(canvas, params, args, clearCanvas);\n\t\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t\tctx.clearRect(\n\t\t\t\tparams.x - params.width / 2,\n\t\t\t\tparams.y - params.height / 2,\n\t\t\t\tparams.width,\n\t\t\t\tparams.height\n\t\t\t);\n\t\t\t// Restore previous transformation\n\t\t\t_restoreTransform(ctx, params);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Transformation API */\n\n// Restores canvas\n$.fn.saveCanvas = function saveCanvas(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, saveCanvas);\n\n\t\t// Restore a number of times using the given count\n\t\tfor (let i = 0; i < params.count; i += 1) {\n\t\t\t_saveCanvas(ctx, data);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Restores canvas\n$.fn.restoreCanvas = function restoreCanvas(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, restoreCanvas);\n\n\t\t// Restore a number of times using the given count\n\t\tfor (let i = 0; i < params.count; i += 1) {\n\t\t\t_restoreCanvas(ctx, data);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Rotates canvas (internal)\nfunction _rotateCanvas(\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\ttransforms: JCanvasBaseTransforms | null\n) {\n\t// Get conversion factor for radians\n\tparams._toRad = params.inDegrees ? PI / 180 : 1;\n\n\t// Rotate canvas using shape as center of rotation\n\tctx.translate(params.x, params.y);\n\tctx.rotate(params.rotate * params._toRad);\n\tctx.translate(-params.x, -params.y);\n\n\t// If transformation data was given\n\tif (transforms) {\n\t\t// Update transformation data\n\t\ttransforms.rotate += params.rotate * params._toRad;\n\t}\n}\n\n// Scales canvas (internal)\nfunction _scaleCanvas(\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\ttransforms: JCanvasBaseTransforms | null\n) {\n\t// Scale both the x- and y- axis using the 'scale' property\n\tif (params.scale !== 1) {\n\t\tparams.scaleX = params.scaleY = params.scale;\n\t}\n\n\t// Scale canvas using shape as center of rotation\n\tctx.translate(params.x, params.y);\n\tctx.scale(params.scaleX, params.scaleY);\n\tctx.translate(-params.x, -params.y);\n\n\t// If transformation data was given\n\tif (transforms) {\n\t\t// Update transformation data\n\t\ttransforms.scaleX *= params.scaleX;\n\t\ttransforms.scaleY *= params.scaleY;\n\t}\n}\n\n// Translates canvas (internal)\nfunction _translateCanvas(\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\ttransforms: JCanvasBaseTransforms | null\n) {\n\t// Translate both the x- and y-axis using the 'translate' property\n\tif (params.translate) {\n\t\tparams.translateX = params.translateY = params.translate;\n\t}\n\n\t// Translate canvas\n\tctx.translate(params.translateX, params.translateY);\n\n\t// If transformation data was given\n\tif (transforms) {\n\t\t// Update transformation data\n\t\ttransforms.translateX += params.translateX;\n\t\ttransforms.translateY += params.translateY;\n\t}\n}\n\n// Rotates canvas\n$.fn.rotateCanvas = function rotateCanvas(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, rotateCanvas);\n\n\t\t// Autosave transformation state by default\n\t\tif (params.autosave) {\n\t\t\t// Automatically save transformation state by default\n\t\t\t_saveCanvas(ctx, data);\n\t\t}\n\t\t_rotateCanvas(ctx, params, data.transforms);\n\t}\n\treturn $canvases;\n};\n\n// Scales canvas\n$.fn.scaleCanvas = function scaleCanvas(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, scaleCanvas);\n\n\t\t// Autosave transformation state by default\n\t\tif (params.autosave) {\n\t\t\t// Automatically save transformation state by default\n\t\t\t_saveCanvas(ctx, data);\n\t\t}\n\t\t_scaleCanvas(ctx, params, data.transforms);\n\t}\n\treturn $canvases;\n};\n\n// Translates canvas\n$.fn.translateCanvas = function translateCanvas(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, translateCanvas);\n\n\t\t// Autosave transformation state by default\n\t\tif (params.autosave) {\n\t\t\t// Automatically save transformation state by default\n\t\t\t_saveCanvas(ctx, data);\n\t\t}\n\t\t_translateCanvas(ctx, params, data.transforms);\n\t}\n\treturn $canvases;\n};\n\n/* Shape API */\n\n// Draws rectangle\n$.fn.drawRect = function drawRect(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawRect);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\tconst nonNullWidth = params.width || 0;\n\t\tconst nonNullHeight = params.height || 0;\n\t\tctx.beginPath();\n\t\tconst x1 = params.x - nonNullWidth / 2;\n\t\tconst y1 = params.y - nonNullHeight / 2;\n\t\tconst r = abs(params.cornerRadius);\n\t\t// If corner radius is defined and is not zero\n\t\tif (r) {\n\t\t\t// Draw rectangle with rounded corners if cornerRadius is defined\n\t\t\tctx.roundRect(x1, y1, nonNullWidth, nonNullHeight, r);\n\t\t} else {\n\t\t\t// Otherwise, draw rectangle with square corners\n\t\t\tctx.rect(x1, y1, nonNullWidth, nonNullHeight);\n\t\t}\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Close rectangle path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Retrieves a coterminal angle between 0 and 2pi for the given angle\nfunction _getCoterminal(angle: number) {\n\twhile (angle < 0) {\n\t\tangle += 2 * PI;\n\t}\n\treturn angle;\n}\n\n// Retrieves the x-coordinate for the given angle in an arc/ellipse\nfunction _getConicX(x: number, radiusX: number, angle: number) {\n\treturn x + radiusX * cos(angle);\n}\n// Retrieves the y-coordinate for the given angle in an arc/ellipse\nfunction _getConicY(y: number, radiusY: number, angle: number) {\n\treturn y + radiusY * sin(angle);\n}\n\n// Calculate angles and positioning for arcs/ellipses\nfunction _getConicOffsets(params: JCanvasObject, path: JCanvasObject) {\n\t// Determine offset from dragging\n\tconst offsetX = params === path ? 0 : params.x;\n\tconst offsetY = params === path ? 0 : params.y;\n\t// Ensure arrows are pointed correctly for CCW arcs\n\tconst angleDiff = path.ccw ? -PI / 180 : PI / 180;\n\n\tconst pathX = path.x + offsetX;\n\tconst pathY = path.y + offsetY;\n\n\t// Convert angles to radians, then offset to make 0deg due north of arc\n\tconst pathStartAngle = path.start * params._toRad - PI / 2;\n\tconst pathEndAngle =\n\t\t!path.inDegrees && path.end === 360\n\t\t\t? PI * 2\n\t\t\t: path.end * params._toRad - PI / 2;\n\n\treturn { pathX, pathY, angleDiff, pathStartAngle, pathEndAngle };\n}\n\n// Draws arc (internal)\nfunction _drawArc(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject\n) {\n\tconst { pathX, pathY, angleDiff, pathStartAngle, pathEndAngle } =\n\t\t_getConicOffsets(params, path);\n\n\t// Calculate coordinates for start arrow\n\tconst x1 = _getConicX(pathX, path.radius, pathStartAngle + angleDiff);\n\tconst y1 = _getConicY(pathY, path.radius, pathStartAngle + angleDiff);\n\tconst x2 = _getConicX(pathX, path.radius, pathStartAngle);\n\tconst y2 = _getConicY(pathY, path.radius, pathStartAngle);\n\n\t_addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n\n\t// Draw arc\n\tctx.arc(pathX, pathY, path.radius, pathStartAngle, pathEndAngle, path.ccw);\n\n\t// Calculate coordinates for end arrow\n\tconst x3 = _getConicX(pathX, path.radius, pathEndAngle + angleDiff);\n\tconst y3 = _getConicY(pathY, path.radius, pathEndAngle + angleDiff);\n\tconst x4 = _getConicX(pathX, path.radius, pathEndAngle);\n\tconst y4 = _getConicY(pathY, path.radius, pathEndAngle);\n\n\t_addEndArrow(canvas, ctx, params, path, x4, y4, x3, y3);\n}\n\n// Draws ellipse (internal)\nfunction _drawEllipse(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject\n) {\n\tconst { pathX, pathY, angleDiff, pathStartAngle, pathEndAngle } =\n\t\t_getConicOffsets(params, path);\n\n\tconst nonNullWidth = path.width || 0;\n\tconst nonNullHeight = path.height || 0;\n\n\t// Calculate coordinates for start arrow\n\tconst x1 = _getConicX(pathX, nonNullWidth / 2, pathStartAngle + angleDiff);\n\tconst y1 = _getConicY(pathY, nonNullHeight / 2, pathStartAngle + angleDiff);\n\tconst x2 = _getConicX(pathX, nonNullWidth / 2, pathStartAngle);\n\tconst y2 = _getConicY(pathY, nonNullHeight / 2, pathStartAngle);\n\n\t_addStartArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n\n\tctx.ellipse(\n\t\tpathX,\n\t\tpathY,\n\t\tnonNullWidth / 2,\n\t\tnonNullHeight / 2,\n\t\t0,\n\t\tpathStartAngle,\n\t\tpathEndAngle,\n\t\tpath.ccw\n\t);\n\n\t// Calculate coordinates for end arrow\n\tconst x3 = _getConicX(pathX, nonNullWidth / 2, pathEndAngle + angleDiff);\n\tconst y3 = _getConicY(pathY, nonNullHeight / 2, pathEndAngle + angleDiff);\n\tconst x4 = _getConicX(pathX, nonNullWidth / 2, pathEndAngle);\n\tconst y4 = _getConicY(pathY, nonNullHeight / 2, pathEndAngle);\n\n\t_addEndArrow(canvas, ctx, params, path, x4, y4, x3, y3);\n}\n\n// Draws arc or circle\n$.fn.drawArc = function drawArc(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawArc);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params, params.radius * 2);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\tctx.beginPath();\n\t\t_drawArc(canvas, ctx, params, params);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Optionally close path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Draws ellipse\n$.fn.drawEllipse = function drawEllipse(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawEllipse);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t_setGlobalProps(canvas, ctx, params);\n\t\tctx.beginPath();\n\t\t_drawEllipse(canvas, ctx, params, params);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Always close path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Draws a regular (equal-angled) polygon\n$.fn.drawPolygon = function drawPolygon(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawPolygon);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params, params.radius * 2);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Polygon's central angle\n\t\tconst dtheta = (2 * PI) / params.sides;\n\t\t// Half of dtheta\n\t\tconst hdtheta = dtheta / 2;\n\t\t// Polygon's starting angle\n\t\tlet theta = hdtheta + PI / 2;\n\t\t// Distance from polygon's center to the middle of its side\n\t\tconst apothem = params.radius * cos(hdtheta);\n\n\t\t// Calculate path and draw\n\t\tctx.beginPath();\n\t\tfor (let i = 0; i < params.sides; i += 1) {\n\t\t\t// Draw side of polygon\n\t\t\tlet x = params.x + params.radius * cos(theta);\n\t\t\tlet y = params.y + params.radius * sin(theta);\n\n\t\t\t// Plot point on polygon\n\t\t\tctx.lineTo(x, y);\n\n\t\t\t// Project side if chosen\n\t\t\tif (params.concavity) {\n\t\t\t\t// Sides are projected from the polygon's apothem\n\t\t\t\tx =\n\t\t\t\t\tparams.x +\n\t\t\t\t\t(apothem + -apothem * params.concavity) * cos(theta + hdtheta);\n\t\t\t\ty =\n\t\t\t\t\tparams.y +\n\t\t\t\t\t(apothem + -apothem * params.concavity) * sin(theta + hdtheta);\n\t\t\t\tctx.lineTo(x, y);\n\t\t\t}\n\n\t\t\t// Increment theta by delta theta\n\t\t\ttheta += dtheta;\n\t\t}\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Always close path\n\t\tparams.closed = true;\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Draws pie-shaped slice\n$.fn.drawSlice = function drawSlice(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawSlice);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params, params.radius * 2);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Perform extra calculations\n\n\t\t// Convert angles to radians\n\t\tparams.start *= params._toRad;\n\t\tparams.end *= params._toRad;\n\t\t// Consider 0deg at north of arc\n\t\tparams.start -= PI / 2;\n\t\tparams.end -= PI / 2;\n\n\t\t// Find positive equivalents of angles\n\t\tparams.start = _getCoterminal(params.start);\n\t\tparams.end = _getCoterminal(params.end);\n\t\t// Ensure start angle is less than end angle\n\t\tif (params.end < params.start) {\n\t\t\tparams.end += 2 * PI;\n\t\t}\n\n\t\t// Calculate angular position of slice\n\t\tconst angle = (params.start + params.end) / 2;\n\n\t\t// Calculate ratios for slice's angle\n\t\tconst dx = params.radius * params.spread * cos(angle);\n\t\tconst dy = params.radius * params.spread * sin(angle);\n\n\t\t// Adjust position of slice\n\t\tparams.x += dx;\n\t\tparams.y += dy;\n\n\t\t// Draw slice\n\t\tctx.beginPath();\n\t\tctx.arc(\n\t\t\tparams.x,\n\t\t\tparams.y,\n\t\t\tparams.radius,\n\t\t\tparams.start,\n\t\t\tparams.end,\n\t\t\tparams.ccw\n\t\t);\n\t\tctx.lineTo(params.x, params.y);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Always close path\n\t\tparams.closed = true;\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n/* Path API */\n\n// Adds arrow to path using the given properties\nfunction _addArrow(\n\t_canvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject,\n\tx1: number,\n\ty1: number,\n\tx2: number,\n\ty2: number\n) {\n\t// If arrow radius is given and path is not closed\n\tif (path.arrowRadius && !params.closed) {\n\t\t// Calculate angle\n\t\tlet angle = atan2(y2 - y1, x2 - x1);\n\t\t// Adjust angle correctly\n\t\tangle -= PI;\n\t\t// Calculate offset to place arrow at edge of path\n\t\tconst offsetX = params.strokeWidth * cos(angle);\n\t\tconst offsetY = params.strokeWidth * sin(angle);\n\n\t\t// Calculate coordinates for left half of arrow\n\t\tconst leftX = x2 + path.arrowRadius * cos(angle + path.arrowAngle / 2);\n\t\tconst leftY = y2 + path.arrowRadius * sin(angle + path.arrowAngle / 2);\n\t\t// Calculate coordinates for right half of arrow\n\t\tconst rightX = x2 + path.arrowRadius * cos(angle - path.arrowAngle / 2);\n\t\tconst rightY = y2 + path.arrowRadius * sin(angle - path.arrowAngle / 2);\n\n\t\t// Draw left half of arrow\n\t\tctx.moveTo(leftX - offsetX, leftY - offsetY);\n\t\tctx.lineTo(x2 - offsetX, y2 - offsetY);\n\t\t// Draw right half of arrow\n\t\tctx.lineTo(rightX - offsetX, rightY - offsetY);\n\n\t\t// Visually connect arrow to path\n\t\tctx.moveTo(x2 - offsetX, y2 - offsetY);\n\t\tctx.lineTo(x2 + offsetX, y2 + offsetY);\n\t\t// Move back to end of path\n\t\tctx.moveTo(x2, y2);\n\t}\n}\n\n// Optionally adds arrow to start of path\nfunction _addStartArrow(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject,\n\tx1: number,\n\ty1: number,\n\tx2: number,\n\ty2: number\n) {\n\tif (!path._arrowAngleConverted) {\n\t\tpath.arrowAngle *= params._toRad;\n\t\tpath._arrowAngleConverted = true;\n\t}\n\tif (path.startArrow) {\n\t\t_addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n\t}\n}\n\n// Optionally adds arrow to end of path\nfunction _addEndArrow(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject,\n\tx1: number,\n\ty1: number,\n\tx2: number,\n\ty2: number\n) {\n\tif (!path._arrowAngleConverted) {\n\t\tpath.arrowAngle *= params._toRad;\n\t\tpath._arrowAngleConverted = true;\n\t}\n\tif (path.endArrow) {\n\t\t_addArrow(canvas, ctx, params, path, x1, y1, x2, y2);\n\t}\n}\n\n// Draws line (internal)\nfunction _drawLine(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject\n) {\n\tlet l = 2;\n\t_addStartArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath.x2 + params.x,\n\t\tpath.y2 + params.y,\n\t\tpath.x1 + params.x,\n\t\tpath.y1 + params.y\n\t);\n\tif (path.x1 !== undefined && path.y1 !== undefined) {\n\t\tctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n\t}\n\twhile (true) {\n\t\t// Calculate next coordinates\n\t\tconst lx = path[(\"x\" + l) as `x${number}`];\n\t\tconst ly = path[(\"y\" + l) as `y${number}`];\n\t\t// If coordinates are given\n\t\tif (lx !== undefined && ly !== undefined) {\n\t\t\t// Draw next line\n\t\t\tctx.lineTo(lx + params.x, ly + params.y);\n\t\t\tl += 1;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\tl -= 1;\n\t// Optionally add arrows to path\n\t_addEndArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath[(\"x\" + (l - 1)) as `x${number}`] + params.x,\n\t\tpath[(\"y\" + (l - 1)) as `y${number}`] + params.y,\n\t\tpath[(\"x\" + l) as `x${number}`] + params.x,\n\t\tpath[(\"y\" + l) as `y${number}`] + params.y\n\t);\n}\n\n// Draws line\n$.fn.drawLine = function drawLine(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawLine);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Draw each point\n\t\tctx.beginPath();\n\t\t_drawLine(canvas, ctx, params, params);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Optionally close path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Draws quadratic curve (internal)\nfunction _drawQuadratic(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject\n) {\n\tlet l = 2;\n\n\t_addStartArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath.cx1 + params.x,\n\t\tpath.cy1 + params.y,\n\t\tpath.x1 + params.x,\n\t\tpath.y1 + params.y\n\t);\n\n\tif (path.x1 !== undefined && path.y1 !== undefined) {\n\t\tctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n\t}\n\twhile (true) {\n\t\t// Calculate next coordinates\n\t\tconst lx = path[(\"x\" + l) as `x${number}`];\n\t\tconst ly = path[(\"y\" + l) as `y${number}`];\n\t\tconst lcx = path[(\"cx\" + (l - 1)) as `cx${number}`];\n\t\tconst lcy = path[(\"cy\" + (l - 1)) as `cy${number}`];\n\t\t// If coordinates are given\n\t\tif (\n\t\t\tlx !== undefined &&\n\t\t\tly !== undefined &&\n\t\t\tlcx !== undefined &&\n\t\t\tlcy !== undefined\n\t\t) {\n\t\t\t// Draw next curve\n\t\t\tctx.quadraticCurveTo(\n\t\t\t\tlcx + params.x,\n\t\t\t\tlcy + params.y,\n\t\t\t\tlx + params.x,\n\t\t\t\tly + params.y\n\t\t\t);\n\t\t\tl += 1;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\tl -= 1;\n\t_addEndArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath[(\"cx\" + (l - 1)) as `cx${number}`] + params.x,\n\t\tpath[(\"cy\" + (l - 1)) as `cy${number}`] + params.y,\n\t\tpath[(\"x\" + l) as `x${number}`] + params.x,\n\t\tpath[(\"y\" + l) as `y${number}`] + params.y\n\t);\n}\n\n// Draws quadratic curve\n$.fn.drawQuadratic = function drawQuadratic(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawQuadratic);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Draw each point\n\t\tctx.beginPath();\n\t\t_drawQuadratic(canvas, ctx, params, params);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Optionally close path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Draws Bezier curve (internal)\nfunction _drawBezier(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject\n) {\n\tlet l = 2;\n\tlet lc = 1;\n\n\t_addStartArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath.cx1 + params.x,\n\t\tpath.cy1 + params.y,\n\t\tpath.x1 + params.x,\n\t\tpath.y1 + params.y\n\t);\n\n\tif (path.x1 !== undefined && path.y1 !== undefined) {\n\t\tctx.moveTo(path.x1 + params.x, path.y1 + params.y);\n\t}\n\twhile (true) {\n\t\t// Calculate next coordinates\n\t\tconst lx = path[(\"x\" + l) as `x${number}`];\n\t\tconst ly = path[(\"y\" + l) as `y${number}`];\n\t\tconst lcx1 = path[(\"cx\" + lc) as `cx${number}`];\n\t\tconst lcy1 = path[(\"cy\" + lc) as `cy${number}`];\n\t\tconst lcx2 = path[(\"cx\" + (lc + 1)) as `cx${number}`];\n\t\tconst lcy2 = path[(\"cy\" + (lc + 1)) as `cy${number}`];\n\t\t// If next coordinates are given\n\t\tif (\n\t\t\tlx !== undefined &&\n\t\t\tly !== undefined &&\n\t\t\tlcx1 !== undefined &&\n\t\t\tlcy1 !== undefined &&\n\t\t\tlcx2 !== undefined &&\n\t\t\tlcy2 !== undefined\n\t\t) {\n\t\t\t// Draw next curve\n\t\t\tctx.bezierCurveTo(\n\t\t\t\tlcx1 + params.x,\n\t\t\t\tlcy1 + params.y,\n\t\t\t\tlcx2 + params.x,\n\t\t\t\tlcy2 + params.y,\n\t\t\t\tlx + params.x,\n\t\t\t\tly + params.y\n\t\t\t);\n\t\t\tl += 1;\n\t\t\tlc += 2;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\tl -= 1;\n\tlc -= 2;\n\t_addEndArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tpath[(\"cx\" + (lc + 1)) as `cx${number}`] + params.x,\n\t\tpath[(\"cy\" + (lc + 1)) as `cy${number}`] + params.y,\n\t\tpath[(\"x\" + l) as `x${number}`] + params.x,\n\t\tpath[(\"y\" + l) as `y${number}`] + params.y\n\t);\n}\n\n// Draws Bezier curve\n$.fn.drawBezier = function drawBezier(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawBezier);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Draw each point\n\t\tctx.beginPath();\n\t\t_drawBezier(canvas, ctx, params, params);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Optionally close path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Retrieves the x-coordinate for the given vector angle and length\nfunction _getVectorX(params: JCanvasObject, angle: number, length: number) {\n\tangle *= params._toRad;\n\tangle -= PI / 2;\n\treturn length * cos(angle);\n}\n// Retrieves the y-coordinate for the given vector angle and length\nfunction _getVectorY(params: JCanvasObject, angle: number, length: number) {\n\tangle *= params._toRad;\n\tangle -= PI / 2;\n\treturn length * sin(angle);\n}\n\n// Draws vector (internal) #2\nfunction _drawVector(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tpath: JCanvasObject\n) {\n\t// Determine offset from dragging\n\tlet offsetX: number;\n\tlet offsetY: number;\n\tif (params === path) {\n\t\toffsetX = 0;\n\t\toffsetY = 0;\n\t} else {\n\t\toffsetX = params.x;\n\t\toffsetY = params.y;\n\t}\n\n\tlet l = 1;\n\tconst x = path.x + offsetX;\n\tlet x3 = x;\n\tlet x4 = x;\n\tconst y = path.y + offsetY;\n\tlet y3 = y;\n\tlet y4 = y;\n\n\t_addStartArrow(\n\t\tcanvas,\n\t\tctx,\n\t\tparams,\n\t\tpath,\n\t\tx + _getVectorX(params, path.a1, path.l1),\n\t\ty + _getVectorY(params, path.a1, path.l1),\n\t\tx,\n\t\ty\n\t);\n\n\t// The vector starts at the given (x, y) coordinates\n\tif (path.x !== undefined && path.y !== undefined) {\n\t\tctx.moveTo(x, y);\n\t}\n\twhile (true) {\n\t\tconst angle = path[(\"a\" + l) as `a${number}`];\n\t\tconst length = path[(\"l\" + l) as `l${number}`];\n\n\t\tif (angle !== undefined && length !== undefined) {\n\t\t\t// Convert the angle to radians with 0 degrees starting at north\n\t\t\t// Keep track of last two coordinates\n\t\t\tx3 = x4;\n\t\t\ty3 = y4;\n\t\t\t// Compute (x, y) coordinates from angle and length\n\t\t\tx4 += _getVectorX(params, angle, length);\n\t\t\ty4 += _getVectorY(params, angle, length);\n\t\t\tctx.lineTo(x4, y4);\n\t\t\tl += 1;\n\t\t} else {\n\t\t\t// Otherwise, stop drawing\n\t\t\tbreak;\n\t\t}\n\t}\n\t_addEndArrow(canvas, ctx, params, path, x3, y3, x4, y4);\n}\n\n// Draws vector\n$.fn.drawVector = function drawVector(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawVector);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Draw each point\n\t\tctx.beginPath();\n\t\t_drawVector(canvas, ctx, params, params);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Optionally close path\n\t\t_closePath(canvas, ctx, params);\n\t}\n\treturn $canvases;\n};\n\n// Draws a path consisting of one or more subpaths\n$.fn.drawPath = function drawPath(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\tif (params.d) {\n\t\t\t// The only way to offset an SVG path drawn with Path2D() is to\n\t\t\t// translate it (making sure we undo the translation it at the end\n\t\t\t// of the method); note that we cannot use ctx.save() and\n\t\t\t// ctx.restore() because it would cause any masking to be undone at\n\t\t\t// the end of the drawPath() code\n\t\t\tctx.translate(params.x, params.y);\n\t\t\tparams._path = caches.pathCache[params.d] || new Path2D(params.d);\n\t\t\tcaches.pathCache[params.d] = params._path;\n\t\t}\n\t\t_addLayer(canvas, params, args, drawPath);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t_transformShape(canvas, ctx, params);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\tif (!params.d) {\n\t\t\tctx.beginPath();\n\t\t\tlet l = 1;\n\t\t\twhile (true) {\n\t\t\t\tlet lp = params[(\"p\" + l) as keyof typeof params];\n\t\t\t\tif (lp !== undefined) {\n\t\t\t\t\tlp = new jCanvasObject(lp);\n\t\t\t\t\tif (lp.type === \"line\") {\n\t\t\t\t\t\t_drawLine(canvas, ctx, params, lp);\n\t\t\t\t\t} else if (lp.type === \"quadratic\") {\n\t\t\t\t\t\t_drawQuadratic(canvas, ctx, params, lp);\n\t\t\t\t\t} else if (lp.type === \"bezier\") {\n\t\t\t\t\t\t_drawBezier(canvas, ctx, params, lp);\n\t\t\t\t\t} else if (lp.type === \"vector\") {\n\t\t\t\t\t\t_drawVector(canvas, ctx, params, lp);\n\t\t\t\t\t} else if (lp.type === \"arc\") {\n\t\t\t\t\t\t_drawArc(canvas, ctx, params, lp);\n\t\t\t\t\t} else if (lp.type === \"ellipse\") {\n\t\t\t\t\t\t_drawEllipse(canvas, ctx, params, lp);\n\t\t\t\t\t}\n\t\t\t\t\tl += 1;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Optionally close path\n\t\t_closePath(canvas, ctx, params);\n\n\t\t// Remember to restore the earlier translation\n\t\tif (params.d) {\n\t\t\tctx.translate(-params.x, -params.y);\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n/* Text API */\n\n// Calculates font string and set it as the canvas font\nfunction _setCanvasFont(\n\t_canvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject\n) {\n\t// Otherwise, use the given font attributes\n\tif (!isNaN(Number(params.fontSize))) {\n\t\t// Give font size units if it doesn't have any\n\t\tparams.fontSize += \"px\";\n\t}\n\t// Set font using given font properties\n\tctx.font = params.fontStyle + \" \" + params.fontSize + \" \" + params.fontFamily;\n}\n\n// Measures canvas text\nfunction _measureText(\n\tcanvas: HTMLCanvasElement,\n\tctx: CanvasRenderingContext2D,\n\tparams: JCanvasObject,\n\tlines: string[]\n) {\n\tconst propCache = caches.propCache;\n\n\t// Used cached width/height if possible\n\tif (\n\t\tpropCache.width &&\n\t\tpropCache.height &&\n\t\tpropCache.text === params.text &&\n\t\tpropCache.fontStyle === params.fontStyle &&\n\t\tpropCache.fontSize === params.fontSize &&\n\t\tpropCache.fontFamily === params.fontFamily &&\n\t\tpropCache.maxWidth === params.maxWidth &&\n\t\tpropCache.lineHeight === params.lineHeight\n\t) {\n\t\tparams.width = propCache.width;\n\t\tparams.height = propCache.height;\n\t} else {\n\t\t// Calculate text dimensions only once\n\n\t\t// Calculate width of first line (for comparison)\n\t\tparams.width = ctx.measureText(lines[0]).width;\n\n\t\t// Get width of longest line\n\t\tfor (let l = 1; l < lines.length; l += 1) {\n\t\t\tconst curWidth = ctx.measureText(lines[l]).width;\n\t\t\t// Ensure text's width is the width of its longest line\n\t\t\tif (curWidth > params.width) {\n\t\t\t\tparams.width = curWidth;\n\t\t\t}\n\t\t}\n\n\t\t// Save original font size\n\t\tconst originalSize = canvas.style.fontSize;\n\t\t// Temporarily set canvas font size to retrieve size in pixels\n\t\tcanvas.style.fontSize = params.fontSize;\n\t\t// Save text width and height in parameters object\n\t\tparams.height =\n\t\t\tparseFloat($.css(canvas, \"fontSize\")) * lines.length * params.lineHeight;\n\t\t// Reset font size to original size\n\t\tcanvas.style.fontSize = originalSize;\n\t}\n}\n\n// Wraps a string of text within a defined width\nfunction _wrapText(ctx: CanvasRenderingContext2D, params: JCanvasObject) {\n\tconst allText = String(params.text);\n\t// Maximum line width (optional)\n\tconst maxWidth = params.maxWidth;\n\t// Lines created by manual line breaks (\\n)\n\tconst manualLines = allText.split(\"\\n\");\n\t// All lines created manually and by wrapping\n\tlet allLines: string[] = [];\n\n\t// Loop through manually-broken lines\n\tfor (let l = 0; l < manualLines.length; l += 1) {\n\t\tconst text = manualLines[l];\n\t\t// Split line into list of words\n\t\tconst words = text.split(\" \");\n\t\tlet lines = [];\n\t\tlet line = \"\";\n\n\t\t// If text is short enough initially\n\t\t// Or, if the text consists of only one word\n\t\tif (\n\t\t\twords.length === 1 ||\n\t\t\t(maxWidth && ctx.measureText(text).width < maxWidth)\n\t\t) {\n\t\t\t// No need to wrap text\n\t\t\tlines = [text];\n\t\t} else {\n\t\t\t// Wrap lines\n\t\t\tfor (let w = 0; w < words.length; w += 1) {\n\t\t\t\t// Once line gets too wide, push word to next line\n\t\t\t\tif (maxWidth && ctx.measureText(line + words[w]).width > maxWidth) {\n\t\t\t\t\t// This check prevents empty lines from being created\n\t\t\t\t\tif (line !== \"\") {\n\t\t\t\t\t\tlines.push(line);\n\t\t\t\t\t}\n\t\t\t\t\t// Start new line and repeat process\n\t\t\t\t\tline = \"\";\n\t\t\t\t}\n\t\t\t\t// Add words to line until the line is too wide\n\t\t\t\tline += words[w];\n\t\t\t\t// Do not add a space after the last word\n\t\t\t\tif (w !== words.length - 1) {\n\t\t\t\t\tline += \" \";\n\t\t\t\t}\n\t\t\t}\n\t\t\t// The last word should always be pushed\n\t\t\tlines.push(line);\n\t\t}\n\t\t// Remove extra space at the end of each line\n\t\tallLines = allLines.concat(\n\t\t\tlines\n\t\t\t\t.join(\"\\n\")\n\t\t\t\t.replace(/((\\n))|($)/gi, \"$2\")\n\t\t\t\t.split(\"\\n\")\n\t\t);\n\t}\n\n\treturn allLines;\n}\n\n// Draws text on canvas\n$.fn.drawText = function drawText(args) {\n\tconst $canvases = this;\n\tconst constantCloseness = 500;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, drawText);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Set text-specific properties\n\t\tctx.textBaseline = params.baseline;\n\t\tctx.textAlign = params.align;\n\n\t\t// Set canvas font using given properties\n\t\t_setCanvasFont(canvas, ctx, params);\n\n\t\tlet lines: string[];\n\t\tif (params.maxWidth !== null) {\n\t\t\t// Wrap text using an internal function\n\t\t\tlines = _wrapText(ctx, params);\n\t\t} else {\n\t\t\t// Convert string of text to list of lines\n\t\t\tlines = params.text.toString().split(\"\\n\");\n\t\t}\n\n\t\t// Calculate text's width and height\n\t\t_measureText(canvas, ctx, params, lines);\n\n\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t// Adjust text position to accomodate different horizontal alignments\n\t\tlet x = params.x;\n\t\tif (params.align === \"left\" && params.width) {\n\t\t\tif (params.respectAlign) {\n\t\t\t\t// Realign text to the left if chosen\n\t\t\t\tparams.x += params.width / 2;\n\t\t\t} else {\n\t\t\t\t// Center text block by default\n\t\t\t\tx -= params.width / 2;\n\t\t\t}\n\t\t} else if (params.align === \"right\" && params.width) {\n\t\t\tif (params.respectAlign) {\n\t\t\t\t// Realign text to the right if chosen\n\t\t\t\tparams.x -= params.width / 2;\n\t\t\t} else {\n\t\t\t\t// Center text block by default\n\t\t\t\tx += params.width / 2;\n\t\t\t}\n\t\t}\n\n\t\tif (params.radius) {\n\t\t\tconst fontSize = parseFloat(params.fontSize);\n\n\t\t\t// Greater values move clockwise\n\t\t\tif (params.letterSpacing === null) {\n\t\t\t\tparams.letterSpacing = fontSize / constantCloseness;\n\t\t\t}\n\n\t\t\t// Loop through each line of text\n\t\t\tfor (let l = 0; l < lines.length; l += 1) {\n\t\t\t\tctx.save();\n\t\t\t\tctx.translate(params.x, params.y);\n\t\t\t\tlet line = lines[l];\n\t\t\t\tlet chars: string[];\n\t\t\t\tif (params.flipArcText) {\n\t\t\t\t\tchars = line.split(\"\");\n\t\t\t\t\tchars.reverse();\n\t\t\t\t\tline = chars.join(\"\");\n\t\t\t\t}\n\t\t\t\tconst nchars = line.length;\n\t\t\t\tctx.rotate(-(PI * params.letterSpacing * (nchars - 1)) / 2);\n\t\t\t\t// Loop through characters on each line\n\t\t\t\tfor (let c = 0; c < nchars; c += 1) {\n\t\t\t\t\tconst ch = line[c];\n\t\t\t\t\t// If character is not the first character\n\t\t\t\t\tif (c !== 0) {\n\t\t\t\t\t\t// Rotate character onto arc\n\t\t\t\t\t\tctx.rotate(PI * params.letterSpacing);\n\t\t\t\t\t}\n\t\t\t\t\tctx.save();\n\t\t\t\t\tctx.translate(0, -params.radius);\n\t\t\t\t\tif (params.flipArcText) {\n\t\t\t\t\t\tctx.scale(-1, -1);\n\t\t\t\t\t}\n\t\t\t\t\tctx.fillText(ch, 0, 0);\n\t\t\t\t\t// Prevent extra shadow created by stroke (but only when fill is present)\n\t\t\t\t\tif (params.fillStyle !== \"transparent\") {\n\t\t\t\t\t\tctx.shadowColor = \"transparent\";\n\t\t\t\t\t}\n\t\t\t\t\tif (params.strokeWidth !== 0) {\n\t\t\t\t\t\t// Only stroke if the stroke is not 0\n\t\t\t\t\t\tctx.strokeText(ch, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tctx.restore();\n\t\t\t\t}\n\t\t\t\tparams.radius -= fontSize;\n\t\t\t\tparams.letterSpacing += fontSize / (constantCloseness * 2 * PI);\n\t\t\t\tctx.restore();\n\t\t\t}\n\t\t} else {\n\t\t\t// Draw each line of text separately\n\t\t\tfor (let l = 0; l < lines.length; l += 1) {\n\t\t\t\tconst line = lines[l];\n\t\t\t\t// Add line offset to center point, but subtract some to center everything\n\t\t\t\tconst y =\n\t\t\t\t\tparams.y +\n\t\t\t\t\t(l * (params.height || 0)) / lines.length -\n\t\t\t\t\t((lines.length - 1) * (params.height || 0)) / lines.length / 2;\n\n\t\t\t\tctx.shadowColor = params.shadowColor;\n\n\t\t\t\t// Fill & stroke text\n\t\t\t\tctx.fillText(line, x, y);\n\t\t\t\t// Prevent extra shadow created by stroke (but only when fill is present)\n\t\t\t\tif (params.fillStyle !== \"transparent\") {\n\t\t\t\t\tctx.shadowColor = \"transparent\";\n\t\t\t\t}\n\t\t\t\tif (params.strokeWidth !== 0) {\n\t\t\t\t\t// Only stroke if the stroke is not 0\n\t\t\t\t\tctx.strokeText(line, x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Adjust bounding box according to text baseline\n\t\tlet y = 0;\n\t\tif (params.baseline === \"top\") {\n\t\t\ty += (params.height || 0) / 2;\n\t\t} else if (params.baseline === \"bottom\") {\n\t\t\ty -= (params.height || 0) / 2;\n\t\t}\n\n\t\t// Detect jCanvas events\n\t\tif (params._event) {\n\t\t\tconst nonNullWidth = params.width || 0;\n\t\t\tconst nonNullHeight = params.height || 0;\n\t\t\tctx.beginPath();\n\t\t\tctx.rect(\n\t\t\t\tparams.x - nonNullWidth / 2,\n\t\t\t\tparams.y - nonNullHeight / 2 + y,\n\t\t\t\tnonNullWidth,\n\t\t\t\tnonNullHeight\n\t\t\t);\n\t\t\t_detectEvents(canvas, ctx, params);\n\t\t\t// Close path and configure masking\n\t\t\tctx.closePath();\n\t\t}\n\t\t_restoreTransform(ctx, params);\n\t\t// Cache jCanvas parameters object for efficiency\n\t\tif (params) {\n\t\t\tcaches.propCache = params;\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Measures text width/height using the given parameters\n$.fn.measureText = function measureText(args) {\n\tconst $canvases = this;\n\n\t// Attempt to retrieve layer\n\tconst params =\n\t\t$canvases.getLayer(args) || new jCanvasObject(args as JCanvasObject);\n\n\tconst canvas = $canvases[0];\n\tif (!_isCanvas(canvas)) {\n\t\treturn params;\n\t}\n\tconst ctx = _getContext(canvas);\n\tif (!ctx) {\n\t\treturn params;\n\t}\n\t// Set canvas font using given properties\n\t_setCanvasFont(canvas, ctx, params);\n\t// Calculate width and height of text\n\tlet lines: string[];\n\tif (params.maxWidth !== null) {\n\t\tlines = _wrapText(ctx, params);\n\t} else {\n\t\tlines = params.text.split(\"\\n\");\n\t}\n\t_measureText(canvas, ctx, params, lines);\n\n\treturn params;\n};\n\n/* Image API */\n\n// Draws image on canvas\n$.fn.drawImage = function drawImage(args) {\n\tconst $canvases = this;\n\tconst imageCache = caches.imageCache;\n\tlet img: HTMLImageElement | HTMLCanvasElement | null = null,\n\t\tsource: JCanvasObject[\"source\"];\n\n\t// Draw image function\n\tfunction draw(\n\t\tcanvas: HTMLCanvasElement,\n\t\tctx: CanvasRenderingContext2D,\n\t\tdata: JCanvasInternalData,\n\t\tparams: JCanvasObject,\n\t\tlayer: JCanvasObject | null\n\t) {\n\t\tif (!img) {\n\t\t\treturn;\n\t\t}\n\t\t// If width and sWidth are not defined, use image width\n\t\tif (params.width === null && params.sWidth === null) {\n\t\t\tparams.width = params.sWidth = img.width;\n\t\t}\n\t\t// If width and sHeight are not defined, use image height\n\t\tif (params.height === null && params.sHeight === null) {\n\t\t\tparams.height = params.sHeight = img.height;\n\t\t}\n\n\t\t// Ensure image layer's width and height are accurate\n\t\tif (layer) {\n\t\t\tlayer.width = params.width;\n\t\t\tlayer.height = params.height;\n\t\t}\n\n\t\tconst nonNullWidth = params.width || 0;\n\t\tconst nonNullHeight = params.height || 0;\n\n\t\t// Only crop image if all cropping properties are given\n\t\tif (\n\t\t\tparams.sWidth !== null &&\n\t\t\tparams.sHeight !== null &&\n\t\t\tparams.sx !== null &&\n\t\t\tparams.sy !== null\n\t\t) {\n\t\t\t// If width is not defined, use the given sWidth\n\t\t\tif (params.width === null) {\n\t\t\t\tparams.width = params.sWidth;\n\t\t\t}\n\t\t\t// If height is not defined, use the given sHeight\n\t\t\tif (params.height === null) {\n\t\t\t\tparams.height = params.sHeight;\n\t\t\t}\n\n\t\t\t// Optionally crop from top-left corner of region\n\t\t\tif (params.cropFromCenter) {\n\t\t\t\tparams.sx += params.sWidth / 2;\n\t\t\t\tparams.sy += params.sHeight / 2;\n\t\t\t}\n\n\t\t\t// Ensure cropped region does not escape image boundaries\n\n\t\t\t// Top\n\t\t\tif (params.sy - params.sHeight / 2 < 0) {\n\t\t\t\tparams.sy = params.sHeight / 2;\n\t\t\t}\n\t\t\t// Bottom\n\t\t\tif (params.sy + params.sHeight / 2 > img.height) {\n\t\t\t\tparams.sy = img.height - params.sHeight / 2;\n\t\t\t}\n\t\t\t// Left\n\t\t\tif (params.sx - params.sWidth / 2 < 0) {\n\t\t\t\tparams.sx = params.sWidth / 2;\n\t\t\t}\n\t\t\t// Right\n\t\t\tif (params.sx + params.sWidth / 2 > img.width) {\n\t\t\t\tparams.sx = img.width - params.sWidth / 2;\n\t\t\t}\n\n\t\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t\t// Draw image\n\t\t\tctx.drawImage(\n\t\t\t\timg,\n\t\t\t\tparams.sx - params.sWidth / 2,\n\t\t\t\tparams.sy - params.sHeight / 2,\n\t\t\t\tparams.sWidth,\n\t\t\t\tparams.sHeight,\n\t\t\t\tparams.x - params.width / 2,\n\t\t\t\tparams.y - params.height / 2,\n\t\t\t\tparams.width,\n\t\t\t\tparams.height\n\t\t\t);\n\t\t} else {\n\t\t\t// Show entire image if no crop region is defined\n\n\t\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\t\t\t_setGlobalProps(canvas, ctx, params);\n\n\t\t\t// Draw image on canvas\n\t\t\tctx.drawImage(\n\t\t\t\timg,\n\t\t\t\tparams.x - nonNullWidth / 2,\n\t\t\t\tparams.y - nonNullHeight / 2,\n\t\t\t\tnonNullWidth,\n\t\t\t\tnonNullHeight\n\t\t\t);\n\t\t}\n\n\t\t// Draw invisible rectangle to allow for events and masking\n\t\tctx.beginPath();\n\t\tctx.rect(\n\t\t\tparams.x - nonNullWidth / 2,\n\t\t\tparams.y - nonNullHeight / 2,\n\t\t\tnonNullWidth,\n\t\t\tnonNullHeight\n\t\t);\n\t\t// Check for jCanvas events\n\t\t_detectEvents(canvas, ctx, params);\n\t\t// Close path and configure masking\n\t\tctx.closePath();\n\t\t_restoreTransform(ctx, params);\n\t\t_enableMasking(ctx, data, params);\n\t}\n\t// On load function\n\tfunction onload(\n\t\tcanvas: HTMLCanvasElement,\n\t\tctx: CanvasRenderingContext2D,\n\t\tdata: JCanvasInternalData,\n\t\tparams: JCanvasObject,\n\t\tlayer: JCanvasObject | null\n\t) {\n\t\treturn function () {\n\t\t\tconst $canvas = $(canvas);\n\t\t\tdraw(canvas, ctx, data, params, layer);\n\t\t\tif (params.layer && layer instanceof jCanvasLayer) {\n\t\t\t\t// Trigger 'load' event for layers\n\t\t\t\t_triggerLayerEvent($canvas, data, layer, \"load\");\n\t\t\t} else if (params.load) {\n\t\t\t\t// Run 'load' callback for non-layers\n\t\t\t\tparams.load.call($canvas[0], layer);\n\t\t\t}\n\t\t\t// Continue drawing successive layers after this image layer has loaded\n\t\t\tif (params.layer && layer) {\n\t\t\t\t// Store list of previous masks for each layer\n\t\t\t\tlayer._masks = data.transforms.masks.slice(0);\n\t\t\t\tif (params._next) {\n\t\t\t\t\t// Draw successive layers\n\t\t\t\t\tconst complete = data.drawLayersComplete;\n\t\t\t\t\tdelete data.drawLayersComplete;\n\t\t\t\t\t$canvas.drawLayers({\n\t\t\t\t\t\tclear: false,\n\t\t\t\t\t\tresetFire: true,\n\t\t\t\t\t\tindex: params._next,\n\t\t\t\t\t\tcomplete: complete,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\t\tconst params = _getParamsObject(args);\n\t\tconst layer = _addLayer(canvas, params, args, drawImage);\n\t\tif (!params.visible) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Cache the given source\n\t\tsource = params.source;\n\n\t\tif (\n\t\t\tsource instanceof HTMLImageElement ||\n\t\t\tsource instanceof HTMLCanvasElement\n\t\t) {\n\t\t\t// Use image or canvas element if given\n\t\t\timg = source;\n\t\t} else if (source) {\n\t\t\tconst cachedImg = imageCache[source];\n\t\t\tif (cachedImg?.complete) {\n\t\t\t\t// Get the image element from the cache if possible\n\t\t\t\timg = cachedImg;\n\t\t\t} else {\n\t\t\t\t// Otherwise, get the image from the given source URL\n\t\t\t\timg = new Image();\n\t\t\t\t// If source URL is not a data URL\n\t\t\t\tif (!source.match(/^data:/i)) {\n\t\t\t\t\t// Set crossOrigin for this image\n\t\t\t\t\timg.crossOrigin = params.crossOrigin;\n\t\t\t\t}\n\t\t\t\timg.src = source;\n\t\t\t\t// Save image in cache for improved performance\n\t\t\t\timageCache[source] = img;\n\t\t\t}\n\t\t}\n\n\t\tif (img) {\n\t\t\tif (\n\t\t\t\t(img instanceof HTMLImageElement && img.complete) ||\n\t\t\t\timg instanceof HTMLCanvasElement\n\t\t\t) {\n\t\t\t\t// Draw image if already loaded\n\t\t\t\tonload(canvas, ctx, data, params, layer)();\n\t\t\t} else {\n\t\t\t\t// Otherwise, draw image when it loads\n\t\t\t\timg.onload = onload(canvas, ctx, data, params, layer);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Creates a canvas pattern object\n$.fn.createPattern = function createPattern(args) {\n\tconst $canvases = this;\n\tlet img: HTMLCanvasElement | HTMLImageElement;\n\tlet pattern: CanvasPattern | null = null;\n\n\t// Function to be called when pattern loads\n\tfunction onload(ctx: CanvasRenderingContext2D, params: JCanvasObject) {\n\t\t// Create pattern\n\t\tpattern = ctx.createPattern(img, params.repeat);\n\t\t// Run callback function if defined\n\t\tif (params.load && pattern) {\n\t\t\tparams.load.call($canvases[0], pattern);\n\t\t}\n\t}\n\n\tconst canvas = $canvases[0];\n\tif (!_isCanvas(canvas)) {\n\t\treturn null;\n\t}\n\tconst ctx = _getContext(canvas);\n\tif (!ctx) {\n\t\treturn null;\n\t}\n\tconst params = _getParamsObject(args);\n\n\t// Cache the given source\n\tconst source = params.source;\n\n\t// Draw when image is loaded (if load() callback function is defined)\n\n\tif (isFunction(source)) {\n\t\t// Draw pattern using function if given\n\n\t\timg = document.createElement(\"canvas\");\n\t\timg.width = params.width || 0;\n\t\timg.height = params.height || 0;\n\t\tconst imgCtx = _getContext(img);\n\t\tsource.call(img, imgCtx);\n\t\tonload(ctx, params);\n\t} else {\n\t\t// Otherwise, draw pattern using source image\n\n\t\tif (\n\t\t\tsource instanceof HTMLImageElement ||\n\t\t\tsource instanceof HTMLCanvasElement\n\t\t) {\n\t\t\t// Use image element if given\n\t\t\timg = source;\n\t\t} else {\n\t\t\t// Use URL if given to get the image\n\t\t\timg = new Image();\n\t\t\t// If source URL is not a data URL\n\t\t\tif (!source.match(/^data:/i)) {\n\t\t\t\t// Set crossOrigin for this image\n\t\t\t\timg.crossOrigin = params.crossOrigin;\n\t\t\t}\n\t\t\timg.src = source;\n\t\t}\n\n\t\t// Create pattern if already loaded\n\t\tif (\n\t\t\t(img instanceof HTMLImageElement && img.complete) ||\n\t\t\timg instanceof HTMLCanvasElement\n\t\t) {\n\t\t\tonload(ctx, params);\n\t\t} else {\n\t\t\timg.onload = () => onload(ctx, params);\n\t\t}\n\t}\n\treturn pattern;\n};\n\n// Creates a canvas gradient object\n$.fn.createGradient = function createGradient(args) {\n\tconst $canvases = this;\n\tlet gradient: CanvasGradient | null = null;\n\tconst stops: (number | null)[] = [];\n\n\tconst params = _getParamsObject(args);\n\tconst canvas = $canvases[0];\n\tif (!_isCanvas(canvas)) {\n\t\treturn null;\n\t}\n\tconst ctx = _getContext(canvas);\n\tif (!ctx) {\n\t\treturn null;\n\t}\n\t// Gradient coordinates must be defined\n\tparams.x1 = params.x1 || 0;\n\tparams.y1 = params.y1 || 0;\n\tparams.x2 = params.x2 || 0;\n\tparams.y2 = params.y2 || 0;\n\n\tif (params.r1 !== null && params.r2 !== null) {\n\t\t// Create radial gradient if chosen\n\t\tgradient = ctx.createRadialGradient(\n\t\t\tparams.x1,\n\t\t\tparams.y1,\n\t\t\tparams.r1,\n\t\t\tparams.x2,\n\t\t\tparams.y2,\n\t\t\tparams.r2\n\t\t);\n\t} else {\n\t\t// Otherwise, create a linear gradient by default\n\t\tgradient = ctx.createLinearGradient(\n\t\t\tparams.x1,\n\t\t\tparams.y1,\n\t\t\tparams.x2,\n\t\t\tparams.y2\n\t\t);\n\t}\n\n\t// Count number of color stops\n\tfor (\n\t\tlet i = 1;\n\t\tparams[(\"c\" + i) as keyof typeof params] !== undefined;\n\t\ti += 1\n\t) {\n\t\tif (params[(\"s\" + i) as keyof typeof params] !== undefined) {\n\t\t\tstops.push(params[(\"s\" + i) as keyof typeof params]);\n\t\t} else {\n\t\t\tstops.push(null);\n\t\t}\n\t}\n\tconst nstops = stops.length;\n\n\t// Define start stop if not already defined\n\tif (stops[0] === null) {\n\t\tstops[0] = 0;\n\t}\n\t// Define end stop if not already defined\n\tif (stops[nstops - 1] === null) {\n\t\tstops[nstops - 1] = 1;\n\t}\n\n\t// Loop through color stops to fill in the blanks\n\tfor (let i = 0; i < nstops; i += 1) {\n\t\t// A progression, in this context, is defined as all of the color stops between and including two known color stops\n\t\tlet p: number = 0;\n\t\tlet start: number | null = null;\n\t\tlet end: number | null = null;\n\t\t// Number of stops in current progression\n\t\tlet n = 1;\n\t\tif (stops[i] !== null) {\n\t\t\t// Start a new progression if stop is a number\n\n\t\t\t// Current iteration in current progression\n\t\t\tp = 0;\n\t\t\tstart = stops[i];\n\n\t\t\t// Look ahead to find end stop\n\t\t\tlet a;\n\t\t\tfor (a = i + 1; a < nstops; a += 1) {\n\t\t\t\tif (stops[a] !== null) {\n\t\t\t\t\t// If this future stop is a number, make it the end stop for this progression\n\t\t\t\t\tend = stops[a];\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t// Otherwise, keep looking ahead\n\t\t\t\t\tn += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Ensure start stop is not greater than end stop\n\t\t\tif (start! > end!) {\n\t\t\t\tstops[a] = stops[i];\n\t\t\t}\n\t\t} else if (stops[i] === null) {\n\t\t\t// Calculate stop if not initially given\n\t\t\tp += 1;\n\t\t\tstops[i] = start! + p * ((end! - start!) / n);\n\t\t}\n\t\t// Add color stop to gradient object\n\t\tconst stop = stops[i];\n\t\tif (stop !== null) {\n\t\t\tgradient.addColorStop(\n\t\t\t\tstop,\n\t\t\t\tparams[(\"c\" + (i + 1)) as keyof typeof params]\n\t\t\t);\n\t\t}\n\t}\n\treturn gradient;\n};\n\n// Manipulates pixels on the canvas\n$.fn.setPixels = function setPixels(args) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tconst canvasData = _getCanvasData(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst params = _getParamsObject(args);\n\t\t_addLayer(canvas, params, args, setPixels);\n\t\t_transformShape(canvas, ctx, params, params.width, params.height);\n\n\t\t// Use entire canvas of x, y, width, or height is not defined\n\t\tif (params.width === null || params.height === null) {\n\t\t\tparams.width = canvas.width;\n\t\t\tparams.height = canvas.height;\n\t\t\tparams.x = params.width / 2;\n\t\t\tparams.y = params.height / 2;\n\t\t}\n\n\t\tif (params.width !== 0 && params.height !== 0) {\n\t\t\t// Only set pixels if width and height are not zero\n\n\t\t\tconst imgData = ctx.getImageData(\n\t\t\t\t(params.x - params.width / 2) * canvasData.pixelRatio,\n\t\t\t\t(params.y - params.height / 2) * canvasData.pixelRatio,\n\t\t\t\tparams.width * canvasData.pixelRatio,\n\t\t\t\tparams.height * canvasData.pixelRatio\n\t\t\t);\n\t\t\tconst pixelData = imgData.data;\n\t\t\tconst len = pixelData.length;\n\n\t\t\t// Loop through pixels with the \"each\" callback function\n\t\t\tif (params.each) {\n\t\t\t\tfor (let i = 0; i < len; i += 4) {\n\t\t\t\t\tconst px = {\n\t\t\t\t\t\tr: pixelData[i],\n\t\t\t\t\t\tg: pixelData[i + 1],\n\t\t\t\t\t\tb: pixelData[i + 2],\n\t\t\t\t\t\ta: pixelData[i + 3],\n\t\t\t\t\t};\n\t\t\t\t\tparams.each.call(canvas, px, params);\n\t\t\t\t\tpixelData[i] = px.r;\n\t\t\t\t\tpixelData[i + 1] = px.g;\n\t\t\t\t\tpixelData[i + 2] = px.b;\n\t\t\t\t\tpixelData[i + 3] = px.a;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Put pixels on canvas\n\t\t\tctx.putImageData(\n\t\t\t\timgData,\n\t\t\t\t(params.x - params.width / 2) * canvasData.pixelRatio,\n\t\t\t\t(params.y - params.height / 2) * canvasData.pixelRatio\n\t\t\t);\n\t\t\t// Restore transformation\n\t\t\tctx.restore();\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Retrieves canvas image as data URL\n$.fn.getCanvasImage = function getCanvasImage(type, quality) {\n\tconst $canvases = this;\n\tif ($canvases.length !== 0) {\n\t\tconst canvas = $canvases[0];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\treturn null;\n\t\t}\n\t\t// JPEG quality defaults to 1\n\t\tif (quality === undefined) {\n\t\t\tquality = 1;\n\t\t}\n\t\treturn canvas.toDataURL(\"image/\" + type, quality);\n\t}\n\treturn null;\n};\n\n// Scales canvas based on the device's pixel ratio\n$.fn.detectPixelRatio = function detectPixelRatio(callback) {\n\tconst $canvases = this;\n\n\tfor (let e = 0; e < $canvases.length; e += 1) {\n\t\t// Get canvas and its associated data\n\t\tconst canvas = $canvases[e];\n\t\tif (!_isCanvas(canvas)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst ctx = _getContext(canvas);\n\t\tif (!ctx) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst data = _getCanvasData(canvas);\n\n\t\t// If canvas has not already been scaled with this method\n\t\tif (!data.scaled) {\n\t\t\t// Determine device pixel ratios\n\t\t\tconst ratio = window.devicePixelRatio || 1;\n\n\t\t\tif (ratio !== 1) {\n\t\t\t\t// Scale canvas relative to ratio\n\n\t\t\t\t// Get the current canvas dimensions for future use\n\t\t\t\tconst oldWidth = canvas.width;\n\t\t\t\tconst oldHeight = canvas.height;\n\n\t\t\t\t// Resize canvas relative to the determined ratio\n\t\t\t\tcanvas.width = oldWidth * ratio;\n\t\t\t\tcanvas.height = oldHeight * ratio;\n\n\t\t\t\t// Scale canvas back to original dimensions via CSS\n\t\t\t\tcanvas.style.width = oldWidth + \"px\";\n\t\t\t\tcanvas.style.height = oldHeight + \"px\";\n\n\t\t\t\t// Scale context to counter the manual scaling of canvas\n\t\t\t\tctx.scale(ratio, ratio);\n\t\t\t}\n\n\t\t\t// Set pixel ratio on canvas data object\n\t\t\tdata.pixelRatio = ratio;\n\t\t\t// Ensure that this method can only be called once for any given canvas\n\t\t\tdata.scaled = true;\n\n\t\t\t// Call the given callback function with the ratio as its only argument\n\t\t\tif (callback) {\n\t\t\t\tcallback.call(canvas, ratio);\n\t\t\t}\n\t\t}\n\t}\n\treturn $canvases;\n};\n\n// Clears the jCanvas cache\njCanvas.clearCache = function clearCache() {\n\tfor (const cacheName in caches) {\n\t\tif (Object.prototype.hasOwnProperty.call(caches, cacheName)) {\n\t\t\tcaches[cacheName as keyof typeof caches] = {};\n\t\t}\n\t}\n};\n\n// Export jCanvas functions\nextendObject(jCanvas, {\n\tdefaults: defaults,\n\tsetGlobalProps: _setGlobalProps,\n\ttransformShape: _transformShape,\n\tdetectEvents: _detectEvents,\n\tclosePath: _closePath,\n\tsetCanvasFont: _setCanvasFont,\n\tmeasureText: _measureText,\n});\n$.jCanvas = jCanvas;\n$.jCanvasObject = jCanvasObject;\n"],
  "mappings": "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",
  "names": ["extendObject", "inArray", "$", "typeOf", "operand", "isPlainObject", "PI", "round", "abs", "sin", "cos", "atan2", "jQueryEventFix", "maps", "caches", "baseTransforms", "css", "tangibleEvents", "jCanvas", "jCanvasDefaults", "defaults", "jCanvasObject", "args", "jCanvasLayer", "canvas", "params", "_getParamsObject", "isString", "isFunction", "isNumeric", "_isCanvas", "element", "_getContext", "_coerceNumericProps", "props", "propName", "propValue", "_cloneTransforms", "transforms", "_saveCanvas", "ctx", "data", "_restoreCanvas", "lastTransform", "_setStyle", "styleName", "styleValue", "_setGlobalProps", "_enableMasking", "_restoreTransform", "_closePath", "_getCanvasData", "_transformShape", "_canvas", "width", "height", "_rotateCanvas", "_scaleCanvas", "_translateCanvas", "plugin", "self", "$canvases", "e", "_addLayer", "JCanvasInternalData", "dataCache", "_addLayerEvents", "$canvas", "layer", "eventName", "_addExplicitLayerEvent", "shouldRedraw", "dragLayer", "_triggerLayerEvent", "l", "_addLayerEvent", "_enableDrag", "dragHelperEvents", "i", "_updateLayerName", "nameMap", "_updateLayerGroups", "groupMap", "index", "g", "groupName", "group", "eventHooks", "callback", "matching", "layers", "layerId", "idType", "layerIndex", "layerPattern", "layerName", "groupId", "groupPattern", "groups", "propType", "_getIntersectingLayer", "mask", "m", "_drawLayer", "nextLayerIndex", "_handleLayerDrag", "eventType", "drag", "dragGroups", "newX", "newY", "_setCursor", "cursor", "_resetCursor", "_runEventCallback", "callbacks", "arg", "_layerCanFireEvent", "isImageLayer", "lastIndex", "eventCache", "lastLayer", "_getMouseEventName", "method", "newLayer", "_showProps", "obj", "p", "cssProp", "_hideProps", "reset", "_parseEndValues", "endValues", "subPropName", "subPropValue", "_removeSubPropAliases", "_normalizeColor", "color", "headElem", "originalColor", "normalizedColor", "_convertColorToRgbArray", "rgbMatches", "multiple", "_blendColors", "color1", "color2", "percentage", "r1", "g1", "b1", "a1", "r2", "g2", "b2", "a2", "r", "b", "a", "complete", "step", "now", "fx", "parts", "hidden", "duration", "clearQueue", "_supportColorProps", "tween", "_getTouchEventName", "_createEvent", "helperEventName", "touchEventName", "eventCallback", "event", "_createEvents", "eventNames", "n", "_detectEvents", "intersects", "x", "y", "angle", "originalEvent", "touches", "offset", "draw", "fn", "clearCanvas", "saveCanvas", "restoreCanvas", "rotateCanvas", "scaleCanvas", "translateCanvas", "drawRect", "nonNullWidth", "nonNullHeight", "x1", "y1", "_getCoterminal", "_getConicX", "radiusX", "_getConicY", "radiusY", "_getConicOffsets", "path", "offsetX", "offsetY", "angleDiff", "pathX", "pathY", "pathStartAngle", "pathEndAngle", "_drawArc", "x2", "y2", "_addStartArrow", "x3", "y3", "x4", "y4", "_addEndArrow", "_drawEllipse", "drawArc", "drawEllipse", "drawPolygon", "dtheta", "hdtheta", "theta", "apothem", "drawSlice", "dx", "dy", "_addArrow", "leftX", "leftY", "rightX", "rightY", "_drawLine", "lx", "ly", "drawLine", "_drawQuadratic", "lcx", "lcy", "drawQuadratic", "_drawBezier", "lc", "lcx1", "lcy1", "lcx2", "lcy2", "drawBezier", "_getVectorX", "length", "_getVectorY", "_drawVector", "drawVector", "drawPath", "lp", "_setCanvasFont", "_measureText", "lines", "propCache", "curWidth", "originalSize", "_wrapText", "allText", "maxWidth", "manualLines", "allLines", "text", "words", "line", "w", "drawText", "constantCloseness", "fontSize", "chars", "nchars", "c", "ch", "drawImage", "imageCache", "img", "source", "onload", "cachedImg", "pattern", "imgCtx", "gradient", "stops", "nstops", "start", "end", "stop", "setPixels", "canvasData", "imgData", "pixelData", "len", "px", "type", "quality", "ratio", "oldWidth", "oldHeight", "cacheName"]
}
